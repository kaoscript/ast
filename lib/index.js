// Generated by kaoscript 0.11.0
const {Helper, Type} = require("@kaoscript/runtime");
module.exports = function() {
	const __ksType = {
		isPosition: value => Type.isDexObject(value, 1, 0, {line: Type.isNumber, column: Type.isNumber}),
		isRange: value => Type.isDexObject(value, 1, 0, {start: __ksType.isPosition, end: __ksType.isPosition}),
		isVersionData: value => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {major: Type.isString, minor: Type.isString, patch: Type.isString}),
		isMacroElementData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = MacroElementKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, MacroElementKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === MacroElementKind.Expression) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), reification: value => __ksType.isReificationData(value, cast) || Type.isNull(value), separator: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === MacroElementKind.Literal) {
				return Type.isDexObject(value, 0, 0, {value: Type.isString});
			}
			return true;
		}}),
		isReificationData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", ReificationKind, cast)}),
		isModifierData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = ModifierKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, ModifierKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === ModifierKind.Rest) {
				return Type.isDexObject(value, 0, 0, {arity: value => Type.isDexObject(value, 1, 0, {min: Type.isNumber, max: Type.isNumber}) || Type.isNull(value)});
			}
			return true;
		}}),
		isNodeData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = NodeKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, NodeKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === NodeKind.AccessorDeclaration) {
				return Type.isDexObject(value, 0, 0, {body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value)) || Type.isNull(value)});
			}
			if(variant === NodeKind.Argument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ArrayBinding) {
				return Type.isDexObject(value, 0, 0, {elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.BindingElement)), alias: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.ArrayComprehension) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), iteration: value => __ksType.isIterationData(value, cast)});
			}
			if(variant === NodeKind.ArrayExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), values: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.ArrayRange) {
				return Type.isDexObject(value, 0, 0, {from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), then: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), til: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), by: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.ArrayType) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.PropertyType)), rest: value => __ksType.isNodeData(value, cast, value => value === NodeKind.PropertyType) || Type.isNull(value)});
			}
			if(variant === NodeKind.AttributeDeclaration) {
				return Type.isDexObject(value, 0, 0, {declaration: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.AttributeExpression || value === NodeKind.AttributeOperation)});
			}
			if(variant === NodeKind.AttributeExpression) {
				return Type.isDexObject(value, 0, 0, {name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.AttributeOperation || value === NodeKind.AttributeExpression))});
			}
			if(variant === NodeKind.AttributeOperation) {
				return Type.isDexObject(value, 0, 0, {name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), value: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Literal)});
			}
			if(variant === NodeKind.AwaitExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), variables: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclarator)) || Type.isNull(value), operation: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.BinaryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isBinaryOperatorData(value, cast), left: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), right: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || NodeKind.__ks_eq_Type(value)) || Type.isNull(value)});
			}
			if(variant === NodeKind.BindingElement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)) || Type.isNull(value), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), external: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), internal: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding || value === NodeKind.ThisExpression) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), operator: value => __ksType.isBinaryOperatorData(value, cast, value => value === OperatorKind.Assignment) || Type.isNull(value), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.BitmaskDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), type: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.BitmaskValue || value === NodeKind.MethodDeclaration))});
			}
			if(variant === NodeKind.BitmaskValue) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.Block) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), statements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Statement))});
			}
			if(variant === NodeKind.BlockStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), label: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block)});
			}
			if(variant === NodeKind.BreakStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), label: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.CallExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), scope: value => __ksType.isScopeData(value, cast), callee: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Argument(value) || NodeKind.__ks_eq_Expression(value)))});
			}
			if(variant === NodeKind.CatchClause) {
				return Type.isDexObject(value, 0, 0, {body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block), binding: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.ClassDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeParameter)) || Type.isNull(value), version: value => __ksType.isVersionData(value) || Type.isNull(value), extends: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression) || Type.isNull(value), implements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression)) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_ClassMember))});
			}
			if(variant === NodeKind.ComparisonExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), values: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || __ksType.isBinaryOperatorData(value, cast))});
			}
			if(variant === NodeKind.ComputedPropertyName) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ContinueStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), label: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.CurryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), scope: value => __ksType.isScopeData(value, cast), callee: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Argument(value) || NodeKind.__ks_eq_Expression(value)))});
			}
			if(variant === NodeKind.DeclarationSpecifier) {
				return Type.isDexObject(value, 0, 0, {declaration: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_SpecialDeclaration)});
			}
			if(variant === NodeKind.DiscloseDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeParameter)) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_ClassMember))});
			}
			if(variant === NodeKind.DisruptiveExpression) {
				return Type.isDexObject(value, 0, 0, {operator: value => __ksType.isRestrictiveOperatorData(value, cast), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), mainExpression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), disruptedExpression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.DoUntilStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block)});
			}
			if(variant === NodeKind.DoWhileStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block)});
			}
			if(variant === NodeKind.EnumDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), type: value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeReference) || Type.isNull(value), initial: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), step: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.EnumValue || value === NodeKind.FieldDeclaration || value === NodeKind.MethodDeclaration))});
			}
			if(variant === NodeKind.EnumValue) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Argument(value) || NodeKind.__ks_eq_Expression(value))) || Type.isNull(value)});
			}
			if(variant === NodeKind.ExclusionType) {
				return Type.isDexObject(value, 0, 0, {types: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type))});
			}
			if(variant === NodeKind.ExportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.DeclarationSpecifier || value === NodeKind.GroupSpecifier || value === NodeKind.NamedSpecifier || value === NodeKind.PropertiesSpecifier))});
			}
			if(variant === NodeKind.ExpressionStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ExternDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.ExternOrImportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ImportDeclarator))});
			}
			if(variant === NodeKind.ExternOrRequireDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.FallthroughStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration))});
			}
			if(variant === NodeKind.FieldDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.ForStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), iterations: value => Type.isArray(value, value => __ksType.isIterationData(value, cast)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.ExpressionStatement), else: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block) || Type.isNull(value)});
			}
			if(variant === NodeKind.FunctionDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeParameter)) || Type.isNull(value), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value) || value === NodeKind.IfStatement || value === NodeKind.UnlessStatement) || Type.isNull(value)});
			}
			if(variant === NodeKind.FunctionExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value) || value === NodeKind.IfStatement || value === NodeKind.UnlessStatement) || Type.isNull(value)});
			}
			if(variant === NodeKind.FusionType) {
				return Type.isDexObject(value, 0, 0, {types: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type))});
			}
			if(variant === NodeKind.GroupSpecifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.NamedSpecifier || value === NodeKind.TypedSpecifier)), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType) || Type.isNull(value)});
			}
			if(variant === NodeKind.Identifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: Type.isString});
			}
			if(variant === NodeKind.IfExpression) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), declaration: value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclaration) || Type.isNull(value), whenTrue: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.SetStatement), whenFalse: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.IfExpression || value === NodeKind.SetStatement)});
			}
			if(variant === NodeKind.IfStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), declarations: value => Type.isArray(value, value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclaration || NodeKind.__ks_eq_Expression(value)))) || Type.isNull(value), whenTrue: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.BreakStatement || value === NodeKind.ContinueStatement || value === NodeKind.ExpressionStatement || value === NodeKind.ReturnStatement || value === NodeKind.SetStatement || value === NodeKind.ThrowStatement), whenFalse: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.IfStatement) || Type.isNull(value)});
			}
			if(variant === NodeKind.ImplementDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), variable: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression), interface: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression) || Type.isNull(value), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_ClassMember))});
			}
			if(variant === NodeKind.ImportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ImportDeclarator))});
			}
			if(variant === NodeKind.ImportDeclarator) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), source: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Literal), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.NamedArgument || value === NodeKind.PositionalArgument)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_DescriptiveType(value) || value === NodeKind.TypeList) || Type.isNull(value), specifiers: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.GroupSpecifier || value === NodeKind.NamedSpecifier))});
			}
			if(variant === NodeKind.IncludeAgainDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.IncludeDeclarator))});
			}
			if(variant === NodeKind.IncludeDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.IncludeDeclarator))});
			}
			if(variant === NodeKind.IncludeDeclarator) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), file: Type.isString});
			}
			if(variant === NodeKind.JunctionExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isBinaryOperatorData(value, cast), operands: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || NodeKind.__ks_eq_Type(value)))});
			}
			if(variant === NodeKind.LambdaExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value))});
			}
			if(variant === NodeKind.Literal) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: Type.isString});
			}
			if(variant === NodeKind.MacroDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.ExpressionStatement)});
			}
			if(variant === NodeKind.MacroExpression) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), elements: value => Type.isArray(value, value => __ksType.isMacroElementData(value, cast))});
			}
			if(variant === NodeKind.MatchClause) {
				return Type.isDexObject(value, 0, 0, {conditions: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.MatchConditionArray || value === NodeKind.MatchConditionObject || value === NodeKind.MatchConditionRange || value === NodeKind.MatchConditionType)), binding: value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclarator || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding) || Type.isNull(value), filter: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Statement(value))});
			}
			if(variant === NodeKind.MatchConditionArray) {
				return Type.isDexObject(value, 0, 0, {values: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.MatchConditionRange || value === NodeKind.OmittedExpression))});
			}
			if(variant === NodeKind.MatchConditionObject) {
				return Type.isDexObject(value, 0, 0, {properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ObjectMember))});
			}
			if(variant === NodeKind.MatchConditionRange) {
				return Type.isDexObject(value, 0, 0, {from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), then: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), til: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.MatchConditionType) {
				return Type.isDexObject(value, 0, 0, {type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type)});
			}
			if(variant === NodeKind.MatchExpression) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), clauses: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.MatchClause))});
			}
			if(variant === NodeKind.MatchStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), declaration: value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclaration) || Type.isNull(value), clauses: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.MatchClause))});
			}
			if(variant === NodeKind.MemberExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), object: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), property: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.MethodDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeParameter)) || Type.isNull(value), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value) || value === NodeKind.IfStatement || value === NodeKind.UnlessStatement) || Type.isNull(value)});
			}
			if(variant === NodeKind.Module) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), body: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Statement(value) || value === NodeKind.ShebangDeclaration))});
			}
			if(variant === NodeKind.MutatorDeclaration) {
				return Type.isDexObject(value, 0, 0, {body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value)) || Type.isNull(value)});
			}
			if(variant === NodeKind.NamedArgument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), value: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.PlaceholderArgument)});
			}
			if(variant === NodeKind.NamedSpecifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), internal: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding), external: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.NamespaceDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), statements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Statement(value) || NodeKind.__ks_eq_DescriptiveType(value) || value === NodeKind.ExportDeclaration || value === NodeKind.ExternDeclaration))});
			}
			if(variant === NodeKind.NumericExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: Type.isNumber, radix: Type.isNumber});
			}
			if(variant === NodeKind.ObjectBinding) {
				return Type.isDexObject(value, 0, 0, {elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.BindingElement)), alias: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.ObjectComprehension) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.ComputedPropertyName || value === NodeKind.TemplateExpression), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), iteration: value => __ksType.isIterationData(value, cast)});
			}
			if(variant === NodeKind.ObjectExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.ObjectMember) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ComputedPropertyName || value === NodeKind.Literal || value === NodeKind.TemplateExpression) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), value: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.MatchConditionRange) || Type.isNull(value)});
			}
			if(variant === NodeKind.ObjectType) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.PropertyType)), rest: value => __ksType.isNodeData(value, cast, value => value === NodeKind.PropertyType) || Type.isNull(value)});
			}
			if(variant === NodeKind.OmittedExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast))});
			}
			if(variant === NodeKind.PassStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration))});
			}
			if(variant === NodeKind.Parameter) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), external: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), internal: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding || value === NodeKind.ThisExpression) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), operator: value => __ksType.isBinaryOperatorData(value, cast, value => value === OperatorKind.Assignment) || Type.isNull(value), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.PlaceholderArgument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), index: value => __ksType.isNodeData(value, cast, value => value === NodeKind.NumericExpression) || Type.isNull(value)});
			}
			if(variant === NodeKind.PolyadicExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isBinaryOperatorData(value, cast), operands: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.PositionalArgument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.PropertiesSpecifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), object: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.NamedSpecifier))});
			}
			if(variant === NodeKind.PropertyDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), accessor: value => __ksType.isNodeData(value, cast, value => value === NodeKind.AccessorDeclaration) || Type.isNull(value), mutator: value => __ksType.isNodeData(value, cast, value => value === NodeKind.MutatorDeclaration) || Type.isNull(value)});
			}
			if(variant === NodeKind.PropertyType) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === NodeKind.ProxyDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), internal: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), external: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ProxyGroupDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), recipient: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ProxyDeclaration))});
			}
			if(variant === NodeKind.Reference) {
				return Type.isDexObject(value, 0, 0, {name: Type.isString});
			}
			if(variant === NodeKind.RegularExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: Type.isString});
			}
			if(variant === NodeKind.RepeatStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.ExpressionStatement)});
			}
			if(variant === NodeKind.RequireDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.RequireOrExternDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.RequireOrImportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ImportDeclarator))});
			}
			if(variant === NodeKind.RestrictiveExpression) {
				return Type.isDexObject(value, 0, 0, {operator: value => __ksType.isRestrictiveOperatorData(value, cast), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ReturnStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.RollingExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), object: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), expressions: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.SequenceExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), expressions: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.SetStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.ShebangDeclaration) {
				return Type.isDexObject(value, 0, 0, {command: Type.isString});
			}
			if(variant === NodeKind.ShorthandProperty) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ComputedPropertyName || value === NodeKind.Literal || value === NodeKind.TemplateExpression || value === NodeKind.ThisExpression)});
			}
			if(variant === NodeKind.SpreadExpression) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operand: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.NamedSpecifier))});
			}
			if(variant === NodeKind.StatementList) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), body: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Statement))});
			}
			if(variant === NodeKind.StructDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), extends: value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeReference) || Type.isNull(value), implements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression)) || Type.isNull(value), fields: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.FieldDeclaration))});
			}
			if(variant === NodeKind.TaggedTemplateExpression) {
				return Type.isDexObject(value, 0, 0, {tag: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), template: value => __ksType.isNodeData(value, cast, value => value === NodeKind.TemplateExpression)});
			}
			if(variant === NodeKind.TemplateExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.ThisExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)});
			}
			if(variant === NodeKind.ThrowStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.TopicReference) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast))});
			}
			if(variant === NodeKind.TryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), argument: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.TryStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block), catchClauses: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.CatchClause)), catchClause: value => __ksType.isNodeData(value, cast, value => value === NodeKind.CatchClause) || Type.isNull(value), finalizer: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block) || Type.isNull(value)});
			}
			if(variant === NodeKind.TupleDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), extends: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), implements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression)) || Type.isNull(value), fields: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TupleField))});
			}
			if(variant === NodeKind.TupleField) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.TypedExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type)) || Type.isNull(value)});
			}
			if(variant === NodeKind.TypedSpecifier) {
				return Type.isDexObject(value, 0, 0, {type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType)});
			}
			if(variant === NodeKind.TypeAliasDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeParameter)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type)});
			}
			if(variant === NodeKind.TypeList) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), types: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.TypeParameter) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), constraint: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === NodeKind.TypeReference) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), typeName: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression || value === NodeKind.UnaryExpression) || Type.isNull(value), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type)) || Type.isNull(value), typeSubtypes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)) || __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.UnaryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isUnaryOperatorData(value, cast), argument: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.UnaryTypeExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isUnaryTypeOperatorData(value, cast), argument: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Type(value) || NodeKind.__ks_eq_Expression(value))});
			}
			if(variant === NodeKind.UnionType) {
				return Type.isDexObject(value, 0, 0, {types: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type))});
			}
			if(variant === NodeKind.UnlessStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), whenFalse: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.BreakStatement || value === NodeKind.ContinueStatement || value === NodeKind.ExpressionStatement || value === NodeKind.ReturnStatement || value === NodeKind.SetStatement || value === NodeKind.ThrowStatement)});
			}
			if(variant === NodeKind.UntilStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value))});
			}
			if(variant === NodeKind.VariableDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), variables: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclarator)), operator: value => __ksType.isBinaryOperatorData(value, cast, value => value === OperatorKind.Assignment) || Type.isNull(value), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.VariableDeclarator) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === NodeKind.VariableStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclaration))});
			}
			if(variant === NodeKind.VariantDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), fields: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariantField))});
			}
			if(variant === NodeKind.VariantField) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), names: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === NodeKind.VariantType) {
				return Type.isDexObject(value, 0, 0, {master: value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeReference), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariantField))});
			}
			if(variant === NodeKind.WhileStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.VariableDeclaration), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value))});
			}
			if(variant === NodeKind.WithStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), variables: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.VariableDeclaration)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block), finalizer: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block) || Type.isNull(value)});
			}
			return true;
		}}),
		isAssignmentOperatorKind: value => value === OperatorKind.Addition || value === OperatorKind.BitwiseAnd || value === OperatorKind.BitwiseOr || value === OperatorKind.BitwiseXor || value === OperatorKind.BitwiseLeftShift || value === OperatorKind.BitwiseRightShift || value === OperatorKind.Division || value === OperatorKind.Empty || value === OperatorKind.EmptyCoalescing || value === OperatorKind.Equals || value === OperatorKind.Existential || value === OperatorKind.Finite || value === OperatorKind.IntegerDivision || value === OperatorKind.LogicalAnd || value === OperatorKind.LogicalImply || value === OperatorKind.LogicalOr || value === OperatorKind.LogicalXor || value === OperatorKind.Modulus || value === OperatorKind.Multiplication || value === OperatorKind.NonEmpty || value === OperatorKind.NonExistential || value === OperatorKind.NonFinite || value === OperatorKind.NonFiniteCoalescing || value === OperatorKind.NullCoalescing || value === OperatorKind.Power || value === OperatorKind.Remainder || value === OperatorKind.Return || value === OperatorKind.Subtraction || value === OperatorKind.VariantNo || value === OperatorKind.VariantNoCoalescing || value === OperatorKind.VariantYes,
		isBinaryOperatorKind: value => value === OperatorKind.Addition || value === OperatorKind.Assignment || value === OperatorKind.BackwardPipeline || value === OperatorKind.BitwiseAnd || value === OperatorKind.BitwiseOr || value === OperatorKind.BitwiseXor || value === OperatorKind.BitwiseLeftShift || value === OperatorKind.BitwiseRightShift || value === OperatorKind.Division || value === OperatorKind.Empty || value === OperatorKind.EmptyCoalescing || value === OperatorKind.Equality || value === OperatorKind.Equals || value === OperatorKind.EuclideanDivision || value === OperatorKind.Existential || value === OperatorKind.Finite || value === OperatorKind.ForwardPipeline || value === OperatorKind.GreaterThan || value === OperatorKind.GreaterThanOrEqual || value === OperatorKind.Inequality || value === OperatorKind.IntegerDivision || value === OperatorKind.JunctionAnd || value === OperatorKind.JunctionOr || value === OperatorKind.JunctionXor || value === OperatorKind.LessThan || value === OperatorKind.LessThanOrEqual || value === OperatorKind.LogicalAnd || value === OperatorKind.LogicalImply || value === OperatorKind.LogicalOr || value === OperatorKind.LogicalXor || value === OperatorKind.Match || value === OperatorKind.Mismatch || value === OperatorKind.Modulus || value === OperatorKind.Multiplication || value === OperatorKind.NonEmpty || value === OperatorKind.NonExistential || value === OperatorKind.NonFinite || value === OperatorKind.NonFiniteCoalescing || value === OperatorKind.NullCoalescing || value === OperatorKind.Power || value === OperatorKind.Remainder || value === OperatorKind.Return || value === OperatorKind.Subtraction || value === OperatorKind.TypeAssertion || value === OperatorKind.TypeCasting || value === OperatorKind.TypeEquality || value === OperatorKind.TypeInequality || value === OperatorKind.TypeSignalment || value === OperatorKind.VariantNo || value === OperatorKind.VariantNoCoalescing || value === OperatorKind.VariantYes,
		isUnaryOperatorKind: value => value === OperatorKind.BitwiseNegation || value === OperatorKind.Constant || value === OperatorKind.Existential || value === OperatorKind.Finite || value === OperatorKind.Implicit || value === OperatorKind.Length || value === OperatorKind.LogicalNegation || value === OperatorKind.Negative || value === OperatorKind.NonEmpty || value === OperatorKind.Spread || value === OperatorKind.TypeFitting || value === OperatorKind.TypeNotNull || value === OperatorKind.VariantYes,
		isBinaryOperatorData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = OperatorKind(variant)) === null || !__ksType.isBinaryOperatorKind(variant)) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!__ksType.isBinaryOperatorKind(variant)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === OperatorKind.Assignment) {
				return Type.isDexObject(value, 0, 0, {assignment: () => Helper.castEnumView(value, "assignment", OperatorKind, cast, __ksType.isAssignmentOperatorKind)});
			}
			return true;
		}, modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)) || Type.isNull(value)}),
		isIterationData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = IterationKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, IterationKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === IterationKind.Array) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), value: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), index: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), step: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), split: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === IterationKind.From) {
				return Type.isDexObject(value, 0, 0, {variable: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), step: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === IterationKind.Object) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), value: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), key: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === IterationKind.Range) {
				return Type.isDexObject(value, 0, 0, {value: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), index: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), step: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === IterationKind.Repeat) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			return true;
		}, attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)) || Type.isNull(value), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), until: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), while: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), when: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)}),
		isRestrictiveOperatorData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", RestrictiveOperatorKind, cast), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)) || Type.isNull(value)}),
		isUnaryOperatorData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnumView(value, "kind", OperatorKind, cast, __ksType.isUnaryOperatorKind)}),
		isUnaryTypeOperatorData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", UnaryTypeOperatorKind, cast)}),
		isScopeData: (value, cast) => Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", ScopeKind, cast), value: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Argument(value) || value === NodeKind.Identifier || value === NodeKind.ObjectExpression) || Type.isNull(value)})
	};
	const MacroElementKind = Helper.enum(Number, 0, "Expression", 1, "Literal", 2, "NewLine", 3);
	const ReificationKind = Helper.enum(Number, 0, "Argument", 1, "Expression", 2, "Join", 3, "Statement", 4, "Write", 5);
	const ModifierKind = Helper.enum(Number, 0, "Abstract", 1, "Alias", 2, "Ascending", 3, "Async", 4, "Assist", 5, "AutoEvaluate", 6, "Autofill", 7, "Ballpark", 8, "Computed", 9, "Constant", 10, "Declarative", 11, "Default", 12, "Descending", 13, "Disabled", 14, "Dynamic", 15, "Exclusion", 16, "Existential", 17, "Final", 18, "Forced", 19, "Internal", 20, "LateInit", 21, "LazyInit", 22, "MultiLine", 23, "Mutable", 24, "Named", 25, "NameOnly", 26, "NonEmpty", 27, "NonNullable", 28, "Nullable", 29, "Ordinal", 30, "Override", 31, "Overwrite", 32, "PositionOnly", 33, "Private", 34, "Protected", 35, "Public", 36, "Required", 37, "Rest", 38, "Sealed", 39, "Spread", 40, "Static", 41, "System", 42, "ThisAlias", 43, "Wildcard", 44);
	const NodeKind = Helper.enum(Number, 0, "AccessorDeclaration", 1, "ArrayBinding", 2, "ArrayComprehension", 3, "ArrayExpression", 4, "ArrayRange", 5, "ArrayType", 6, "AttributeDeclaration", 7, "AttributeExpression", 8, "AttributeOperation", 9, "AwaitExpression", 10, "BinaryExpression", 11, "BindingElement", 12, "BitmaskDeclaration", 13, "BitmaskValue", 14, "Block", 15, "BlockStatement", 16, "BreakStatement", 17, "CallExpression", 18, "CatchClause", 19, "ClassDeclaration", 20, "CommentBlock", 21, "CommentLine", 22, "ComparisonExpression", 23, "ComputedPropertyName", 24, "ContinueStatement", 25, "CurryExpression", 26, "DeclarationSpecifier", 27, "DiscloseDeclaration", 28, "DisruptiveExpression", 29, "DoUntilStatement", 30, "DoWhileStatement", 31, "EnumDeclaration", 32, "EnumValue", 33, "ExclusionType", 34, "ExportDeclaration", 35, "ExternDeclaration", 36, "ExternOrImportDeclaration", 37, "ExternOrRequireDeclaration", 38, "ExpressionStatement", 39, "FallthroughStatement", 40, "FieldDeclaration", 41, "ForStatement", 42, "FunctionDeclaration", 43, "FunctionExpression", 44, "FusionType", 45, "GroupSpecifier", 46, "Identifier", 47, "IfExpression", 48, "IfStatement", 49, "ImplementDeclaration", 50, "ImportDeclaration", 51, "ImportDeclarator", 52, "IncludeAgainDeclaration", 53, "IncludeDeclaration", 54, "IncludeDeclarator", 55, "JunctionExpression", 56, "LambdaExpression", 57, "Literal", 58, "MacroDeclaration", 59, "MacroExpression", 60, "MatchClause", 61, "MatchConditionArray", 62, "MatchConditionObject", 63, "MatchConditionRange", 64, "MatchConditionType", 65, "MatchExpression", 66, "MatchStatement", 67, "MemberExpression", 68, "MethodDeclaration", 69, "MixinDeclaration", 70, "Module", 71, "MutatorDeclaration", 72, "NamedArgument", 73, "NamedSpecifier", 74, "NamespaceDeclaration", 75, "NumericExpression", 76, "ObjectBinding", 77, "ObjectComprehension", 78, "ObjectExpression", 79, "ObjectMember", 80, "ObjectType", 81, "OmittedExpression", 82, "Parameter", 83, "PassStatement", 84, "PlaceholderArgument", 85, "PolyadicExpression", 86, "PositionalArgument", 87, "PropertiesSpecifier", 88, "PropertyDeclaration", 89, "PropertyType", 90, "ProxyDeclaration", 91, "ProxyGroupDeclaration", 92, "Reference", 93, "RegularExpression", 94, "RepeatStatement", 95, "RequireDeclaration", 96, "RequireOrExternDeclaration", 97, "RequireOrImportDeclaration", 98, "RestrictiveExpression", 99, "ReturnStatement", 100, "RollingExpression", 101, "SequenceExpression", 102, "SetStatement", 103, "ShebangDeclaration", 104, "ShorthandProperty", 105, "SpreadExpression", 106, "StatementList", 107, "StructDeclaration", 108, "SurrogateDeclaration", 109, "TaggedTemplateExpression", 110, "TemplateExpression", 111, "ThisExpression", 112, "ThrowStatement", 113, "TopicReference", 114, "TraitDeclaration", 115, "TryExpression", 116, "TryStatement", 117, "TupleDeclaration", 118, "TupleField", 119, "TypeAliasDeclaration", 120, "TypeList", 121, "TypeParameter", 122, "TypeReference", 123, "TypedExpression", 124, "TypedSpecifier", 125, "UnaryExpression", 126, "UnaryTypeExpression", 127, "UnlessStatement", 128, "UntilStatement", 129, "UnionType", 130, "VariableDeclaration", 131, "VariableDeclarator", 132, "VariableStatement", 133, "VariantDeclaration", 134, "VariantField", 135, "VariantType", 136, "WhileStatement", 137, "WithStatement", 138);
	NodeKind.__ks_eq_Argument = value => value === NodeKind.NamedArgument || value === NodeKind.PlaceholderArgument || value === NodeKind.PositionalArgument;
	NodeKind.__ks_eq_ClassMember = value => value === NodeKind.FieldDeclaration || value === NodeKind.MacroDeclaration || value === NodeKind.MethodDeclaration || value === NodeKind.PropertyDeclaration || value === NodeKind.ProxyDeclaration || value === NodeKind.ProxyGroupDeclaration;
	NodeKind.__ks_eq_Expression = value => value === NodeKind.ArrayBinding || value === NodeKind.ArrayComprehension || value === NodeKind.ArrayExpression || value === NodeKind.ArrayRange || value === NodeKind.AwaitExpression || value === NodeKind.BinaryExpression || value === NodeKind.CallExpression || value === NodeKind.ComparisonExpression || value === NodeKind.CurryExpression || value === NodeKind.DisruptiveExpression || value === NodeKind.FunctionExpression || value === NodeKind.Identifier || value === NodeKind.IfExpression || value === NodeKind.JunctionExpression || value === NodeKind.LambdaExpression || value === NodeKind.Literal || value === NodeKind.MacroExpression || value === NodeKind.MatchExpression || value === NodeKind.MemberExpression || value === NodeKind.NamedArgument || value === NodeKind.NumericExpression || value === NodeKind.ObjectBinding || value === NodeKind.ObjectComprehension || value === NodeKind.ObjectExpression || value === NodeKind.ObjectMember || value === NodeKind.PlaceholderArgument || value === NodeKind.PolyadicExpression || value === NodeKind.PositionalArgument || value === NodeKind.Reference || value === NodeKind.RegularExpression || value === NodeKind.RestrictiveExpression || value === NodeKind.RollingExpression || value === NodeKind.SequenceExpression || value === NodeKind.ShorthandProperty || value === NodeKind.SpreadExpression || value === NodeKind.TaggedTemplateExpression || value === NodeKind.TemplateExpression || value === NodeKind.ThisExpression || value === NodeKind.TopicReference || value === NodeKind.TryExpression || value === NodeKind.TypedExpression || value === NodeKind.UnaryExpression;
	NodeKind.__ks_eq_Statement = value => value === NodeKind.BitmaskDeclaration || value === NodeKind.BlockStatement || value === NodeKind.BreakStatement || value === NodeKind.ClassDeclaration || value === NodeKind.ContinueStatement || value === NodeKind.DiscloseDeclaration || value === NodeKind.DoUntilStatement || value === NodeKind.DoWhileStatement || value === NodeKind.EnumDeclaration || value === NodeKind.ExportDeclaration || value === NodeKind.ExternDeclaration || value === NodeKind.ExternOrImportDeclaration || value === NodeKind.ExternOrRequireDeclaration || value === NodeKind.ExpressionStatement || value === NodeKind.FallthroughStatement || value === NodeKind.ForStatement || value === NodeKind.FunctionDeclaration || value === NodeKind.IfStatement || value === NodeKind.ImplementDeclaration || value === NodeKind.ImportDeclaration || value === NodeKind.IncludeAgainDeclaration || value === NodeKind.IncludeDeclaration || value === NodeKind.MacroDeclaration || value === NodeKind.MatchStatement || value === NodeKind.NamespaceDeclaration || value === NodeKind.PassStatement || value === NodeKind.RepeatStatement || value === NodeKind.RequireDeclaration || value === NodeKind.RequireOrExternDeclaration || value === NodeKind.RequireOrImportDeclaration || value === NodeKind.ReturnStatement || value === NodeKind.SetStatement || value === NodeKind.StructDeclaration || value === NodeKind.ThrowStatement || value === NodeKind.TraitDeclaration || value === NodeKind.TryStatement || value === NodeKind.TupleDeclaration || value === NodeKind.TypeAliasDeclaration || value === NodeKind.UnlessStatement || value === NodeKind.UntilStatement || value === NodeKind.VariableStatement || value === NodeKind.VariantDeclaration || value === NodeKind.WhileStatement || value === NodeKind.WithStatement;
	NodeKind.__ks_eq_Type = value => value === NodeKind.ArrayType || value === NodeKind.ExclusionType || value === NodeKind.FunctionExpression || value === NodeKind.FusionType || value === NodeKind.ObjectType || value === NodeKind.TypeReference || value === NodeKind.UnaryTypeExpression || value === NodeKind.UnionType || value === NodeKind.VariantType;
	NodeKind.__ks_eq_SpecialDeclaration = value => value === NodeKind.BitmaskDeclaration || value === NodeKind.ClassDeclaration || value === NodeKind.EnumDeclaration || value === NodeKind.FunctionDeclaration || value === NodeKind.MacroDeclaration || value === NodeKind.MacroExpression || value === NodeKind.NamespaceDeclaration || value === NodeKind.StructDeclaration || value === NodeKind.TupleDeclaration || value === NodeKind.TypeAliasDeclaration || value === NodeKind.VariableStatement;
	NodeKind.__ks_eq_DescriptiveType = value => value === NodeKind.BitmaskDeclaration || value === NodeKind.ClassDeclaration || value === NodeKind.EnumDeclaration || value === NodeKind.FunctionDeclaration || value === NodeKind.MacroDeclaration || value === NodeKind.MacroExpression || value === NodeKind.NamespaceDeclaration || value === NodeKind.StructDeclaration || value === NodeKind.TupleDeclaration || value === NodeKind.TypeAliasDeclaration || value === NodeKind.VariableStatement || value === NodeKind.ExportDeclaration || value === NodeKind.VariableDeclarator;
	const OperatorAttribute = Helper.bitmask(Number, ["Nil", 0, "Assignable", 1, "Binary", 2, "Comparable", 4, "Polyadic", 8, "RTL", 16, "Unary", 32]);
	const OperatorKind = Helper.enum(Number, 2, "attribute", "precedence", "Addition", 1, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 13, "Assignment", 2, OperatorAttribute.Binary, 3, "BackwardPipeline", 3, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.RTL), 20, "BitwiseAnd", 4, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "BitwiseNegation", 5, OperatorAttribute.Unary, 0, "BitwiseOr", 6, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "BitwiseXor", 7, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "BitwiseLeftShift", 8, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "BitwiseRightShift", 9, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "Constant", 10, OperatorAttribute.Unary, 0, "Division", 11, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Empty", 12, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "EmptyCoalescing", 13, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 15, "Equality", 14, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "Equals", 15, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "EuclideanDivision", 16, OperatorAttribute.Binary, 14, "Existential", 17, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable | OperatorAttribute.Unary), 0, "Finite", 18, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable | OperatorAttribute.Unary), 0, "ForwardPipeline", 19, OperatorAttribute.Binary, 16, "GreaterThan", 20, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "GreaterThanOrEqual", 21, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "Implicit", 22, OperatorAttribute.Unary, 0, "Inequality", 23, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "IntegerDivision", 24, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "JunctionAnd", 25, OperatorAttribute.Binary, 0, "JunctionOr", 26, OperatorAttribute.Binary, 0, "JunctionXor", 27, OperatorAttribute.Binary, 0, "Length", 28, OperatorAttribute.Unary, 0, "LessThan", 29, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "LessThanOrEqual", 30, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "LogicalAnd", 31, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 6, "LogicalImply", 32, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 5, "LogicalNegation", 33, OperatorAttribute.Unary, 0, "LogicalOr", 34, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 5, "LogicalXor", 35, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 5, "Match", 36, OperatorAttribute.Binary, 8, "Mismatch", 37, OperatorAttribute.Binary, 8, "Modulus", 38, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Multiplication", 39, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Negative", 40, OperatorAttribute.Unary, 0, "NonEmpty", 41, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable | OperatorAttribute.Unary), 0, "NonExistential", 42, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "NonFinite", 43, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "NonFiniteCoalescing", 44, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 15, "NullCoalescing", 45, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 15, "Power", 46, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Remainder", 47, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Return", 48, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "Spread", 49, OperatorAttribute.Unary, 0, "Subtraction", 50, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 13, "TypeAssertion", 51, OperatorAttribute.Binary, 0, "TypeCasting", 52, OperatorAttribute.Binary, 0, "TypeEquality", 53, OperatorAttribute.Binary, 8, "TypeFitting", 54, OperatorAttribute.Unary, 0, "TypeInequality", 55, OperatorAttribute.Binary, 8, "TypeNotNull", 56, OperatorAttribute.Unary, 0, "TypeSignalment", 57, OperatorAttribute.Binary, 0, "VariantNo", 58, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "VariantNoCoalescing", 59, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 15, "VariantYes", 60, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable | OperatorAttribute.Unary), 0);
	const IterationKind = Helper.enum(Number, 0, "Array", 0, "From", 1, "Object", 2, "Range", 3, "Repeat", 4);
	const RestrictiveOperatorKind = Helper.enum(Number, 0, "If", 0, "Unless", 1);
	const UnaryTypeOperatorKind = Helper.enum(Number, 0, "Constant", 1, "Mutable", 2, "NewInstance", 3, "TypeOf", 4, "ValueOf", 5);
	const ScopeKind = Helper.enum(Number, 0, "Argument", 1, "This", 2);
	return {
		MacroElementKind,
		ReificationKind,
		ModifierKind,
		NodeKind,
		OperatorAttribute,
		OperatorKind,
		IterationKind,
		RestrictiveOperatorKind,
		UnaryTypeOperatorKind,
		ScopeKind,
		__ksType: [__ksType.isPosition, __ksType.isRange, __ksType.isVersionData, __ksType.isMacroElementData, __ksType.isReificationData, __ksType.isModifierData, __ksType.isNodeData, __ksType.isAssignmentOperatorKind, __ksType.isBinaryOperatorKind, __ksType.isUnaryOperatorKind, __ksType.isBinaryOperatorData, __ksType.isIterationData, __ksType.isRestrictiveOperatorData, __ksType.isUnaryOperatorData, __ksType.isUnaryTypeOperatorData, __ksType.isScopeData]
	};
};
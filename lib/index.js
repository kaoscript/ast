// Generated by kaoscript 0.11.0
const {Helper, Type} = require("@kaoscript/runtime");
module.exports = function() {
	const __ksType = {
		isPosition: value => Type.isDexObject(value, 1, 0, {line: Type.isNumber, column: Type.isNumber}),
		isRange: value => Type.isDexObject(value, 1, 0, {start: __ksType.isPosition, end: __ksType.isPosition}),
		isVersionData: value => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {major: Type.isString, minor: Type.isString, patch: Type.isString}),
		isModifierData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = ModifierKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, ModifierKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === ModifierKind.Rest) {
				return Type.isDexObject(value, 0, 0, {arity: value => Type.isDexObject(value, 1, 0, {min: Type.isNumber, max: Type.isNumber}) || Type.isNull(value)});
			}
			return true;
		}}),
		isAst: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = AstKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, AstKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === AstKind.AccessorDeclaration) {
				return Type.isDexObject(value, 0, 0, {body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value)) || Type.isNull(value)});
			}
			if(variant === AstKind.Argument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			if(variant === AstKind.ArrayBinding) {
				return Type.isDexObject(value, 0, 0, {elements: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.BindingElement)), alias: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value)});
			}
			if(variant === AstKind.ArrayComprehension) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), iteration: value => __ksType.isIterationData(value, cast)});
			}
			if(variant === AstKind.ArrayExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), values: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression))});
			}
			if(variant === AstKind.ArrayRange) {
				return Type.isDexObject(value, 0, 0, {from: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), then: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), til: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), to: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), by: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.ArrayType) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), properties: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.PropertyType)), rest: value => __ksType.isAst(value, cast, value => value === AstKind.PropertyType) || Type.isNull(value)});
			}
			if(variant === AstKind.AttributeDeclaration) {
				return Type.isDexObject(value, 0, 0, {declaration: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.AttributeExpression || value === AstKind.AttributeOperation)});
			}
			if(variant === AstKind.AttributeExpression) {
				return Type.isDexObject(value, 0, 0, {name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), arguments: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.AttributeOperation || value === AstKind.AttributeExpression))});
			}
			if(variant === AstKind.AttributeOperation) {
				return Type.isDexObject(value, 0, 0, {name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), value: value => __ksType.isAst(value, cast, value => value === AstKind.Literal)});
			}
			if(variant === AstKind.AwaitExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), variables: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.VariableDeclarator)) || Type.isNull(value), operation: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.BinaryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isBinaryOperatorData(value, cast), left: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), right: value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Expression(value) || AstKind.__ks_eq_Type(value)) || Type.isNull(value)});
			}
			if(variant === AstKind.BindingElement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)) || Type.isNull(value), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), external: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), internal: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.ArrayBinding || value === AstKind.ObjectBinding || value === AstKind.ThisExpression) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), operator: value => __ksType.isBinaryOperatorData(value, cast, value => value === OperatorKind.Assignment) || Type.isNull(value), defaultValue: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.BitmaskDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), type: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.BitmaskValue || value === AstKind.MethodDeclaration))});
			}
			if(variant === AstKind.BitmaskValue) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.Block) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), statements: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Statement))});
			}
			if(variant === AstKind.BlockStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), label: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block)});
			}
			if(variant === AstKind.BreakStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), label: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value)});
			}
			if(variant === AstKind.CallExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), scope: value => __ksType.isScopeData(value, cast), callee: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), arguments: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Argument(value) || AstKind.__ks_eq_Expression(value)))});
			}
			if(variant === AstKind.CatchClause) {
				return Type.isDexObject(value, 0, 0, {body: value => __ksType.isAst(value, cast, value => value === AstKind.Block), binding: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), type: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value)});
			}
			if(variant === AstKind.ClassDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.TypeParameter)) || Type.isNull(value), version: value => __ksType.isVersionData(value) || Type.isNull(value), extends: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.MemberExpression) || Type.isNull(value), implements: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.MemberExpression)) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_ClassMember))});
			}
			if(variant === AstKind.ComparisonExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), values: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || __ksType.isBinaryOperatorData(value, cast))});
			}
			if(variant === AstKind.ComputedPropertyName) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			if(variant === AstKind.ContinueStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), label: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value)});
			}
			if(variant === AstKind.CurryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), scope: value => __ksType.isScopeData(value, cast), callee: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), arguments: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Argument(value) || AstKind.__ks_eq_Expression(value)))});
			}
			if(variant === AstKind.DeclarationSpecifier) {
				return Type.isDexObject(value, 0, 0, {declaration: value => __ksType.isAst(value, cast, AstKind.__ks_eq_SpecialDeclaration)});
			}
			if(variant === AstKind.DiscloseDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.TypeParameter)) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_ClassMember))});
			}
			if(variant === AstKind.DisruptiveExpression) {
				return Type.isDexObject(value, 0, 0, {operator: value => __ksType.isRestrictiveOperatorData(value, cast), condition: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), mainExpression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), disruptedExpression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			if(variant === AstKind.DoUntilStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), condition: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block)});
			}
			if(variant === AstKind.DoWhileStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), condition: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block)});
			}
			if(variant === AstKind.EnumDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), type: value => __ksType.isAst(value, cast, value => value === AstKind.TypeReference) || Type.isNull(value), initial: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), step: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.EnumValue || value === AstKind.FieldDeclaration || value === AstKind.MethodDeclaration))});
			}
			if(variant === AstKind.EnumValue) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), arguments: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Argument(value) || AstKind.__ks_eq_Expression(value))) || Type.isNull(value)});
			}
			if(variant === AstKind.ExclusionType) {
				return Type.isDexObject(value, 0, 0, {types: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type))});
			}
			if(variant === AstKind.ExportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.DeclarationSpecifier || value === AstKind.GroupSpecifier || value === AstKind.NamedSpecifier || value === AstKind.PropertiesSpecifier))});
			}
			if(variant === AstKind.ExpressionStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			if(variant === AstKind.ExternDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_DescriptiveType))});
			}
			if(variant === AstKind.ExternOrImportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.ImportDeclarator))});
			}
			if(variant === AstKind.ExternOrRequireDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_DescriptiveType))});
			}
			if(variant === AstKind.FallthroughStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration))});
			}
			if(variant === AstKind.FieldDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.ForStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), iterations: value => Type.isArray(value, value => __ksType.isIterationData(value, cast)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || value === AstKind.ExpressionStatement), else: value => __ksType.isAst(value, cast, value => value === AstKind.Block) || Type.isNull(value)});
			}
			if(variant === AstKind.FunctionDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.TypeParameter)) || Type.isNull(value), parameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Parameter)) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value) || value === AstKind.IfStatement || value === AstKind.UnlessStatement) || Type.isNull(value)});
			}
			if(variant === AstKind.FunctionExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), parameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Parameter)) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value) || value === AstKind.IfStatement || value === AstKind.UnlessStatement) || Type.isNull(value)});
			}
			if(variant === AstKind.FusionType) {
				return Type.isDexObject(value, 0, 0, {types: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type))});
			}
			if(variant === AstKind.GroupSpecifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), elements: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.NamedSpecifier || value === AstKind.TypedSpecifier)), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_DescriptiveType) || Type.isNull(value)});
			}
			if(variant === AstKind.Identifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: Type.isString});
			}
			if(variant === AstKind.IfExpression) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), condition: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), declaration: value => __ksType.isAst(value, cast, value => value === AstKind.VariableDeclaration) || Type.isNull(value), whenTrue: value => __ksType.isAst(value, cast, value => value === AstKind.Block || value === AstKind.SetStatement), whenFalse: value => __ksType.isAst(value, cast, value => value === AstKind.Block || value === AstKind.IfExpression || value === AstKind.SetStatement)});
			}
			if(variant === AstKind.IfStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), condition: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), declarations: value => Type.isArray(value, value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.VariableDeclaration || AstKind.__ks_eq_Expression(value)))) || Type.isNull(value), whenTrue: value => __ksType.isAst(value, cast, value => value === AstKind.Block || value === AstKind.BreakStatement || value === AstKind.ContinueStatement || value === AstKind.ExpressionStatement || value === AstKind.ReturnStatement || value === AstKind.SetStatement || value === AstKind.ThrowStatement), whenFalse: value => __ksType.isAst(value, cast, value => value === AstKind.Block || value === AstKind.IfStatement) || Type.isNull(value)});
			}
			if(variant === AstKind.ImplementDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), variable: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.MemberExpression), interface: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.MemberExpression) || Type.isNull(value), properties: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_ClassMember))});
			}
			if(variant === AstKind.ImportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.ImportDeclarator))});
			}
			if(variant === AstKind.ImportDeclarator) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), source: value => __ksType.isAst(value, cast, value => value === AstKind.Literal), arguments: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.NamedArgument || value === AstKind.PositionalArgument)) || Type.isNull(value), type: value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_DescriptiveType(value) || value === AstKind.TypeList) || Type.isNull(value), specifiers: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.GroupSpecifier || value === AstKind.NamedSpecifier))});
			}
			if(variant === AstKind.IncludeAgainDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.IncludeDeclarator))});
			}
			if(variant === AstKind.IncludeDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.IncludeDeclarator))});
			}
			if(variant === AstKind.IncludeDeclarator) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), file: Type.isString});
			}
			if(variant === AstKind.JunctionExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isBinaryOperatorData(value, cast), operands: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Expression(value) || AstKind.__ks_eq_Type(value)))});
			}
			if(variant === AstKind.LambdaExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), parameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Parameter)) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value))});
			}
			if(variant === AstKind.Literal) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: Type.isString});
			}
			if(variant === AstKind.MacroDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), parameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Parameter)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value))});
			}
			if(variant === AstKind.MatchClause) {
				return Type.isDexObject(value, 0, 0, {conditions: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Expression(value) || value === AstKind.MatchConditionArray || value === AstKind.MatchConditionObject || value === AstKind.MatchConditionRange || value === AstKind.MatchConditionType)), binding: value => __ksType.isAst(value, cast, value => value === AstKind.VariableDeclarator || value === AstKind.ArrayBinding || value === AstKind.ObjectBinding) || Type.isNull(value), filter: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Statement(value))});
			}
			if(variant === AstKind.MatchConditionArray) {
				return Type.isDexObject(value, 0, 0, {values: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Expression(value) || value === AstKind.MatchConditionRange || value === AstKind.OmittedExpression))});
			}
			if(variant === AstKind.MatchConditionObject) {
				return Type.isDexObject(value, 0, 0, {properties: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.ObjectMember))});
			}
			if(variant === AstKind.MatchConditionRange) {
				return Type.isDexObject(value, 0, 0, {from: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), then: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), til: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), to: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.MatchConditionType) {
				return Type.isDexObject(value, 0, 0, {type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type)});
			}
			if(variant === AstKind.MatchExpression) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), clauses: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.MatchClause))});
			}
			if(variant === AstKind.MatchStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), declaration: value => __ksType.isAst(value, cast, value => value === AstKind.VariableDeclaration) || Type.isNull(value), clauses: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.MatchClause))});
			}
			if(variant === AstKind.MemberExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), object: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), property: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			if(variant === AstKind.MethodDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.TypeParameter)) || Type.isNull(value), parameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Parameter)), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value) || value === AstKind.IfStatement || value === AstKind.UnlessStatement) || Type.isNull(value)});
			}
			if(variant === AstKind.Module) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), body: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Statement(value) || value === AstKind.ShebangDeclaration))});
			}
			if(variant === AstKind.MutatorDeclaration) {
				return Type.isDexObject(value, 0, 0, {body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value)) || Type.isNull(value)});
			}
			if(variant === AstKind.NamedArgument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), value: value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Expression(value) || value === AstKind.PlaceholderArgument)});
			}
			if(variant === AstKind.NamedSpecifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), internal: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.MemberExpression || value === AstKind.ArrayBinding || value === AstKind.ObjectBinding), external: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value)});
			}
			if(variant === AstKind.NamespaceDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), statements: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Statement(value) || AstKind.__ks_eq_DescriptiveType(value) || value === AstKind.ExportDeclaration || value === AstKind.ExternDeclaration))});
			}
			if(variant === AstKind.NumericExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: Type.isNumber, radix: Type.isNumber});
			}
			if(variant === AstKind.ObjectBinding) {
				return Type.isDexObject(value, 0, 0, {elements: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.BindingElement)), alias: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value)});
			}
			if(variant === AstKind.ObjectComprehension) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.ComputedPropertyName || value === AstKind.TemplateExpression), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), iteration: value => __ksType.isIterationData(value, cast)});
			}
			if(variant === AstKind.ObjectExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), properties: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression))});
			}
			if(variant === AstKind.ObjectMember) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.ComputedPropertyName || value === AstKind.Literal || value === AstKind.TemplateExpression) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), value: value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Expression(value) || value === AstKind.MatchConditionRange) || Type.isNull(value)});
			}
			if(variant === AstKind.ObjectType) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), properties: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.PropertyType)), rest: value => __ksType.isAst(value, cast, value => value === AstKind.PropertyType) || Type.isNull(value)});
			}
			if(variant === AstKind.OmittedExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast))});
			}
			if(variant === AstKind.Operator) {
				return Type.isDexObject(value, 0, 0, {operator: value => __ksType.isBinaryOperatorData(value, cast)});
			}
			if(variant === AstKind.PassStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration))});
			}
			if(variant === AstKind.Parameter) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), external: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), internal: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.ArrayBinding || value === AstKind.ObjectBinding || value === AstKind.ThisExpression) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), operator: value => __ksType.isBinaryOperatorData(value, cast, value => value === OperatorKind.Assignment) || Type.isNull(value), defaultValue: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.PlaceholderArgument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), index: value => __ksType.isAst(value, cast, value => value === AstKind.NumericExpression) || Type.isNull(value)});
			}
			if(variant === AstKind.PolyadicExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isBinaryOperatorData(value, cast), operands: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression))});
			}
			if(variant === AstKind.PositionalArgument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			if(variant === AstKind.PropertiesSpecifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), object: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.MemberExpression), properties: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.NamedSpecifier))});
			}
			if(variant === AstKind.PropertyDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), defaultValue: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), accessor: value => __ksType.isAst(value, cast, value => value === AstKind.AccessorDeclaration) || Type.isNull(value), mutator: value => __ksType.isAst(value, cast, value => value === AstKind.MutatorDeclaration) || Type.isNull(value)});
			}
			if(variant === AstKind.PropertyType) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === AstKind.ProxyDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), internal: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), external: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			if(variant === AstKind.ProxyGroupDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), recipient: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), elements: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.ProxyDeclaration))});
			}
			if(variant === AstKind.QuoteExpression) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), elements: value => Type.isArray(value, value => __ksType.isQuoteElementData(value, cast))});
			}
			if(variant === AstKind.Reference) {
				return Type.isDexObject(value, 0, 0, {name: Type.isString});
			}
			if(variant === AstKind.RegularExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), value: Type.isString});
			}
			if(variant === AstKind.RepeatStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || value === AstKind.ExpressionStatement)});
			}
			if(variant === AstKind.RequireDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_DescriptiveType))});
			}
			if(variant === AstKind.RequireOrExternDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_DescriptiveType))});
			}
			if(variant === AstKind.RequireOrImportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.ImportDeclarator))});
			}
			if(variant === AstKind.RestrictiveExpression) {
				return Type.isDexObject(value, 0, 0, {operator: value => __ksType.isRestrictiveOperatorData(value, cast), condition: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			if(variant === AstKind.ReturnStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.RollingExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), object: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), expressions: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression))});
			}
			if(variant === AstKind.SequenceExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), expressions: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression))});
			}
			if(variant === AstKind.SemtimeStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value))});
			}
			if(variant === AstKind.SetStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.ShebangDeclaration) {
				return Type.isDexObject(value, 0, 0, {command: Type.isString});
			}
			if(variant === AstKind.ShorthandProperty) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.ComputedPropertyName || value === AstKind.Literal || value === AstKind.TemplateExpression || value === AstKind.ThisExpression)});
			}
			if(variant === AstKind.SpreadExpression) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operand: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), members: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.NamedSpecifier))});
			}
			if(variant === AstKind.StatementList) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), body: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Statement))});
			}
			if(variant === AstKind.StructDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), extends: value => __ksType.isAst(value, cast, value => value === AstKind.TypeReference) || Type.isNull(value), implements: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.MemberExpression)) || Type.isNull(value), fields: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.FieldDeclaration))});
			}
			if(variant === AstKind.SyntimeCallExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), callee: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), arguments: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Argument(value) || AstKind.__ks_eq_Expression(value) || AstKind.__ks_eq_Statement(value)))});
			}
			if(variant === AstKind.SyntimeDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.ImplementDeclaration || value === AstKind.MacroDeclaration || value === AstKind.NamespaceDeclaration))});
			}
			if(variant === AstKind.SyntimeStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block)});
			}
			if(variant === AstKind.TaggedTemplateExpression) {
				return Type.isDexObject(value, 0, 0, {tag: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), template: value => __ksType.isAst(value, cast, value => value === AstKind.TemplateExpression)});
			}
			if(variant === AstKind.TemplateExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), elements: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression))});
			}
			if(variant === AstKind.ThisExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier)});
			}
			if(variant === AstKind.ThrowStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.TopicReference) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast))});
			}
			if(variant === AstKind.TryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), argument: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), defaultValue: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.TryStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block), catchClauses: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.CatchClause)), catchClause: value => __ksType.isAst(value, cast, value => value === AstKind.CatchClause) || Type.isNull(value), finalizer: value => __ksType.isAst(value, cast, value => value === AstKind.Block) || Type.isNull(value)});
			}
			if(variant === AstKind.TupleDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), extends: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), implements: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.MemberExpression)) || Type.isNull(value), fields: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.TupleField))});
			}
			if(variant === AstKind.TupleField) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), defaultValue: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.TypedExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), typeParameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type)) || Type.isNull(value)});
			}
			if(variant === AstKind.TypedSpecifier) {
				return Type.isDexObject(value, 0, 0, {type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_DescriptiveType)});
			}
			if(variant === AstKind.TypeAliasDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.TypeParameter)) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type)});
			}
			if(variant === AstKind.TypeList) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), types: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_DescriptiveType))});
			}
			if(variant === AstKind.TypeParameter) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), constraint: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === AstKind.TypeReference) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), typeName: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.MemberExpression || value === AstKind.UnaryExpression) || Type.isNull(value), typeParameters: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type)) || Type.isNull(value), typeSubtypes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier)) || __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.UnaryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isUnaryOperatorData(value, cast), argument: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			if(variant === AstKind.UnaryTypeExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), operator: value => __ksType.isUnaryTypeOperatorData(value, cast), argument: value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Type(value) || AstKind.__ks_eq_Expression(value))});
			}
			if(variant === AstKind.UnionType) {
				return Type.isDexObject(value, 0, 0, {types: value => Type.isArray(value, value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type))});
			}
			if(variant === AstKind.UnlessStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), condition: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), whenFalse: value => __ksType.isAst(value, cast, value => value === AstKind.Block || value === AstKind.BreakStatement || value === AstKind.ContinueStatement || value === AstKind.ExpressionStatement || value === AstKind.ReturnStatement || value === AstKind.SetStatement || value === AstKind.ThrowStatement)});
			}
			if(variant === AstKind.UntilStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), condition: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value))});
			}
			if(variant === AstKind.VariableDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), variables: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.VariableDeclarator)), operator: value => __ksType.isBinaryOperatorData(value, cast, value => value === OperatorKind.Assignment) || Type.isNull(value), value: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === AstKind.VariableDeclarator) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.ArrayBinding || value === AstKind.ObjectBinding), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === AstKind.VariableStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), declarations: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.VariableDeclaration))});
			}
			if(variant === AstKind.VariantDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), name: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), fields: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.VariantField))});
			}
			if(variant === AstKind.VariantField) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), names: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.Identifier)), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === AstKind.VariantType) {
				return Type.isDexObject(value, 0, 0, {master: value => __ksType.isAst(value, cast, value => value === AstKind.TypeReference), properties: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.VariantField))});
			}
			if(variant === AstKind.WhileStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), condition: value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Expression(value) || value === AstKind.VariableDeclaration), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block || AstKind.__ks_eq_Expression(value))});
			}
			if(variant === AstKind.WithStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)), variables: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Expression(value) || value === AstKind.VariableDeclaration)), body: value => __ksType.isAst(value, cast, value => value === AstKind.Block), finalizer: value => __ksType.isAst(value, cast, value => value === AstKind.Block) || Type.isNull(value)});
			}
			return true;
		}}),
		isAssignmentOperatorKind: value => value === OperatorKind.Addition || value === OperatorKind.BitwiseAnd || value === OperatorKind.BitwiseOr || value === OperatorKind.BitwiseXor || value === OperatorKind.BitwiseLeftShift || value === OperatorKind.BitwiseRightShift || value === OperatorKind.Division || value === OperatorKind.Empty || value === OperatorKind.EmptyCoalescing || value === OperatorKind.Equals || value === OperatorKind.Existential || value === OperatorKind.Finite || value === OperatorKind.IntegerDivision || value === OperatorKind.LogicalAnd || value === OperatorKind.LogicalImply || value === OperatorKind.LogicalOr || value === OperatorKind.LogicalXor || value === OperatorKind.Modulus || value === OperatorKind.Multiplication || value === OperatorKind.NonEmpty || value === OperatorKind.NonExistential || value === OperatorKind.NonFinite || value === OperatorKind.NonFiniteCoalescing || value === OperatorKind.NullCoalescing || value === OperatorKind.Power || value === OperatorKind.Remainder || value === OperatorKind.Return || value === OperatorKind.Subtraction || value === OperatorKind.VariantNo || value === OperatorKind.VariantNoCoalescing || value === OperatorKind.VariantYes,
		isBinaryOperatorKind: value => value === OperatorKind.Addition || value === OperatorKind.Assignment || value === OperatorKind.BackwardPipeline || value === OperatorKind.BitwiseAnd || value === OperatorKind.BitwiseOr || value === OperatorKind.BitwiseXor || value === OperatorKind.BitwiseLeftShift || value === OperatorKind.BitwiseRightShift || value === OperatorKind.Division || value === OperatorKind.Empty || value === OperatorKind.EmptyCoalescing || value === OperatorKind.Equality || value === OperatorKind.Equals || value === OperatorKind.EuclideanDivision || value === OperatorKind.Existential || value === OperatorKind.Finite || value === OperatorKind.ForwardPipeline || value === OperatorKind.GreaterThan || value === OperatorKind.GreaterThanOrEqual || value === OperatorKind.Inequality || value === OperatorKind.IntegerDivision || value === OperatorKind.JunctionAnd || value === OperatorKind.JunctionOr || value === OperatorKind.JunctionXor || value === OperatorKind.LessThan || value === OperatorKind.LessThanOrEqual || value === OperatorKind.LogicalAnd || value === OperatorKind.LogicalImply || value === OperatorKind.LogicalOr || value === OperatorKind.LogicalXor || value === OperatorKind.Match || value === OperatorKind.Mismatch || value === OperatorKind.Modulus || value === OperatorKind.Multiplication || value === OperatorKind.NonEmpty || value === OperatorKind.NonExistential || value === OperatorKind.NonFinite || value === OperatorKind.NonFiniteCoalescing || value === OperatorKind.NullCoalescing || value === OperatorKind.Power || value === OperatorKind.Remainder || value === OperatorKind.Return || value === OperatorKind.Subtraction || value === OperatorKind.TypeAssertion || value === OperatorKind.TypeCasting || value === OperatorKind.TypeEquality || value === OperatorKind.TypeInequality || value === OperatorKind.TypeSignalment || value === OperatorKind.VariantNo || value === OperatorKind.VariantNoCoalescing || value === OperatorKind.VariantYes,
		isUnaryOperatorKind: value => value === OperatorKind.BitwiseNegation || value === OperatorKind.Constant || value === OperatorKind.Existential || value === OperatorKind.Finite || value === OperatorKind.Implicit || value === OperatorKind.Length || value === OperatorKind.LogicalNegation || value === OperatorKind.Negative || value === OperatorKind.NonEmpty || value === OperatorKind.Spread || value === OperatorKind.TypeFitting || value === OperatorKind.TypeNotNull || value === OperatorKind.VariantYes,
		isBinaryOperatorData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = OperatorKind(variant)) === null || !__ksType.isBinaryOperatorKind(variant)) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!__ksType.isBinaryOperatorKind(variant)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === OperatorKind.Assignment) {
				return Type.isDexObject(value, 0, 0, {assignment: () => Helper.castEnumView(value, "assignment", OperatorKind, cast, __ksType.isAssignmentOperatorKind)});
			}
			return true;
		}, modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)) || Type.isNull(value)}),
		isIterationData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = IterationKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, IterationKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === IterationKind.Array) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), value: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.ArrayBinding || value === AstKind.ObjectBinding) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), index: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), from: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), to: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), step: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), split: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === IterationKind.From) {
				return Type.isDexObject(value, 0, 0, {variable: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), from: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), to: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), step: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === IterationKind.Object) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), value: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier || value === AstKind.ArrayBinding || value === AstKind.ObjectBinding) || Type.isNull(value), type: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Type) || Type.isNull(value), key: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value)});
			}
			if(variant === IterationKind.Range) {
				return Type.isDexObject(value, 0, 0, {value: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier), index: value => __ksType.isAst(value, cast, value => value === AstKind.Identifier) || Type.isNull(value), from: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), to: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), step: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === IterationKind.Repeat) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression)});
			}
			return true;
		}, attributes: value => Type.isArray(value, value => __ksType.isAst(value, cast, value => value === AstKind.AttributeDeclaration)) || Type.isNull(value), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)), until: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), while: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value), when: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)}),
		isRestrictiveOperatorData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", RestrictiveOperatorKind, cast), modifiers: value => Type.isArray(value, value => __ksType.isModifierData(value, cast)) || Type.isNull(value)}),
		isUnaryOperatorData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnumView(value, "kind", OperatorKind, cast, __ksType.isUnaryOperatorKind)}),
		isUnaryTypeOperatorData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", UnaryTypeOperatorKind, cast)}),
		isQuoteElementData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = QuoteElementKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, QuoteElementKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === QuoteElementKind.Escape) {
				return Type.isDexObject(value, 0, 0, {value: Type.isString});
			}
			if(variant === QuoteElementKind.Expression) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression), reifications: value => Type.isArray(value, value => __ksType.isReificationData(value, cast)), separator: value => __ksType.isAst(value, cast, AstKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === QuoteElementKind.Literal) {
				return Type.isDexObject(value, 0, 0, {value: Type.isString});
			}
			return true;
		}}),
		isReificationData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", ReificationKind, cast)}),
		isScopeData: (value, cast) => Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", ScopeKind, cast), value: value => __ksType.isAst(value, cast, value => AstKind.__ks_eq_Argument(value) || value === AstKind.Identifier || value === AstKind.ObjectExpression) || Type.isNull(value)})
	};
	const ModifierKind = Helper.enum(Number, 0, "Abstract", 1, "Alias", 2, "Ascending", 3, "Async", 4, "Assist", 5, "Autofill", 6, "Ballpark", 7, "Computed", 8, "Constant", 9, "Declarative", 10, "Default", 11, "Descending", 12, "Disabled", 13, "Dynamic", 14, "Exclusion", 15, "Existential", 16, "Final", 17, "Forced", 18, "Internal", 19, "LateInit", 20, "LazyInit", 21, "MultiLine", 22, "Mutable", 23, "Named", 24, "NameOnly", 25, "NonEmpty", 26, "NonNullable", 27, "Nullable", 28, "Ordinal", 29, "Override", 30, "Overwrite", 31, "PositionOnly", 32, "Private", 33, "Protected", 34, "Public", 35, "Required", 36, "Rest", 37, "Sealed", 38, "Spread", 39, "Static", 40, "System", 41, "ThisAlias", 42, "Wildcard", 43);
	const AstKind = Helper.enum(Number, 0, "AccessorDeclaration", 1, "ArrayBinding", 2, "ArrayComprehension", 3, "ArrayExpression", 4, "ArrayRange", 5, "ArrayType", 6, "AttributeDeclaration", 7, "AttributeExpression", 8, "AttributeOperation", 9, "AwaitExpression", 10, "BinaryExpression", 11, "BindingElement", 12, "BitmaskDeclaration", 13, "BitmaskValue", 14, "Block", 15, "BlockStatement", 16, "BreakStatement", 17, "CallExpression", 18, "CatchClause", 19, "ClassDeclaration", 20, "CommentBlock", 21, "CommentLine", 22, "ComparisonExpression", 23, "ComputedPropertyName", 24, "ContinueStatement", 25, "CurryExpression", 26, "DeclarationSpecifier", 27, "DiscloseDeclaration", 28, "DisruptiveExpression", 29, "DoUntilStatement", 30, "DoWhileStatement", 31, "EnumDeclaration", 32, "EnumValue", 33, "ExclusionType", 34, "ExportDeclaration", 35, "ExternDeclaration", 36, "ExternOrImportDeclaration", 37, "ExternOrRequireDeclaration", 38, "ExpressionStatement", 39, "FallthroughStatement", 40, "FieldDeclaration", 41, "ForStatement", 42, "FunctionDeclaration", 43, "FunctionExpression", 44, "FusionType", 45, "GroupSpecifier", 46, "Identifier", 47, "IfExpression", 48, "IfStatement", 49, "ImplementDeclaration", 50, "ImportDeclaration", 51, "ImportDeclarator", 52, "IncludeAgainDeclaration", 53, "IncludeDeclaration", 54, "IncludeDeclarator", 55, "JunctionExpression", 56, "LambdaExpression", 57, "Literal", 58, "MacroDeclaration", 59, "MatchClause", 60, "MatchConditionArray", 61, "MatchConditionObject", 62, "MatchConditionRange", 63, "MatchConditionType", 64, "MatchExpression", 65, "MatchStatement", 66, "MemberExpression", 67, "MethodDeclaration", 68, "MixinDeclaration", 69, "Module", 70, "MutatorDeclaration", 71, "NamedArgument", 72, "NamedSpecifier", 73, "NamespaceDeclaration", 74, "NumericExpression", 75, "ObjectBinding", 76, "ObjectComprehension", 77, "ObjectExpression", 78, "ObjectMember", 79, "ObjectType", 80, "OmittedExpression", 81, "Operator", 82, "Parameter", 83, "PassStatement", 84, "PlaceholderArgument", 85, "PolyadicExpression", 86, "PositionalArgument", 87, "PropertiesSpecifier", 88, "PropertyDeclaration", 89, "PropertyType", 90, "ProxyDeclaration", 91, "ProxyGroupDeclaration", 92, "QuoteExpression", 93, "Reference", 94, "RegularExpression", 95, "RepeatStatement", 96, "RequireDeclaration", 97, "RequireOrExternDeclaration", 98, "RequireOrImportDeclaration", 99, "RestrictiveExpression", 100, "ReturnStatement", 101, "RollingExpression", 102, "SemtimeStatement", 103, "SequenceExpression", 104, "SetStatement", 105, "ShebangDeclaration", 106, "ShorthandProperty", 107, "SpreadExpression", 108, "StatementList", 109, "StructDeclaration", 110, "SurrogateDeclaration", 111, "SyntimeCallExpression", 112, "SyntimeDeclaration", 113, "SyntimeStatement", 114, "TaggedTemplateExpression", 115, "TemplateExpression", 116, "ThisExpression", 117, "ThrowStatement", 118, "TopicReference", 119, "TraitDeclaration", 120, "TryExpression", 121, "TryStatement", 122, "TupleDeclaration", 123, "TupleField", 124, "TypeAliasDeclaration", 125, "TypeList", 126, "TypeParameter", 127, "TypeReference", 128, "TypedExpression", 129, "TypedSpecifier", 130, "UnaryExpression", 131, "UnaryTypeExpression", 132, "UnlessStatement", 133, "UntilStatement", 134, "UnionType", 135, "VariableDeclaration", 136, "VariableDeclarator", 137, "VariableStatement", 138, "VariantDeclaration", 139, "VariantField", 140, "VariantType", 141, "WhileStatement", 142, "WithStatement", 143);
	AstKind.__ks_eq_Argument = value => value === AstKind.NamedArgument || value === AstKind.PlaceholderArgument || value === AstKind.PositionalArgument;
	AstKind.__ks_eq_ClassMember = value => value === AstKind.FieldDeclaration || value === AstKind.MethodDeclaration || value === AstKind.PropertyDeclaration || value === AstKind.ProxyDeclaration || value === AstKind.ProxyGroupDeclaration || value === AstKind.SyntimeStatement;
	AstKind.__ks_eq_Expression = value => value === AstKind.ArrayBinding || value === AstKind.ArrayComprehension || value === AstKind.ArrayExpression || value === AstKind.ArrayRange || value === AstKind.AwaitExpression || value === AstKind.BinaryExpression || value === AstKind.CallExpression || value === AstKind.ComparisonExpression || value === AstKind.CurryExpression || value === AstKind.DisruptiveExpression || value === AstKind.FunctionExpression || value === AstKind.Identifier || value === AstKind.IfExpression || value === AstKind.JunctionExpression || value === AstKind.LambdaExpression || value === AstKind.Literal || value === AstKind.MatchExpression || value === AstKind.MemberExpression || value === AstKind.NamedArgument || value === AstKind.NumericExpression || value === AstKind.ObjectBinding || value === AstKind.ObjectComprehension || value === AstKind.ObjectExpression || value === AstKind.ObjectMember || value === AstKind.Operator || value === AstKind.PlaceholderArgument || value === AstKind.PolyadicExpression || value === AstKind.PositionalArgument || value === AstKind.QuoteExpression || value === AstKind.Reference || value === AstKind.RegularExpression || value === AstKind.RestrictiveExpression || value === AstKind.RollingExpression || value === AstKind.SequenceExpression || value === AstKind.ShorthandProperty || value === AstKind.SpreadExpression || value === AstKind.SyntimeCallExpression || value === AstKind.TaggedTemplateExpression || value === AstKind.TemplateExpression || value === AstKind.ThisExpression || value === AstKind.TopicReference || value === AstKind.TryExpression || value === AstKind.TypedExpression || value === AstKind.UnaryExpression;
	AstKind.__ks_eq_Statement = value => value === AstKind.BitmaskDeclaration || value === AstKind.BlockStatement || value === AstKind.BreakStatement || value === AstKind.ClassDeclaration || value === AstKind.ContinueStatement || value === AstKind.DiscloseDeclaration || value === AstKind.DoUntilStatement || value === AstKind.DoWhileStatement || value === AstKind.EnumDeclaration || value === AstKind.ExportDeclaration || value === AstKind.ExternDeclaration || value === AstKind.ExternOrImportDeclaration || value === AstKind.ExternOrRequireDeclaration || value === AstKind.ExpressionStatement || value === AstKind.FallthroughStatement || value === AstKind.ForStatement || value === AstKind.FunctionDeclaration || value === AstKind.IfStatement || value === AstKind.ImplementDeclaration || value === AstKind.ImportDeclaration || value === AstKind.IncludeAgainDeclaration || value === AstKind.IncludeDeclaration || value === AstKind.MacroDeclaration || value === AstKind.MatchStatement || value === AstKind.NamespaceDeclaration || value === AstKind.PassStatement || value === AstKind.RepeatStatement || value === AstKind.RequireDeclaration || value === AstKind.RequireOrExternDeclaration || value === AstKind.RequireOrImportDeclaration || value === AstKind.ReturnStatement || value === AstKind.SemtimeStatement || value === AstKind.SetStatement || value === AstKind.StructDeclaration || value === AstKind.SyntimeDeclaration || value === AstKind.SyntimeStatement || value === AstKind.ThrowStatement || value === AstKind.TraitDeclaration || value === AstKind.TryStatement || value === AstKind.TupleDeclaration || value === AstKind.TypeAliasDeclaration || value === AstKind.UnlessStatement || value === AstKind.UntilStatement || value === AstKind.VariableStatement || value === AstKind.VariantDeclaration || value === AstKind.WhileStatement || value === AstKind.WithStatement;
	AstKind.__ks_eq_Type = value => value === AstKind.ArrayType || value === AstKind.ExclusionType || value === AstKind.FunctionExpression || value === AstKind.FusionType || value === AstKind.ObjectType || value === AstKind.TypeReference || value === AstKind.UnaryTypeExpression || value === AstKind.UnionType || value === AstKind.VariantType;
	AstKind.__ks_eq_SpecialDeclaration = value => value === AstKind.BitmaskDeclaration || value === AstKind.ClassDeclaration || value === AstKind.EnumDeclaration || value === AstKind.FunctionDeclaration || value === AstKind.MacroDeclaration || value === AstKind.NamespaceDeclaration || value === AstKind.StructDeclaration || value === AstKind.SyntimeDeclaration || value === AstKind.TupleDeclaration || value === AstKind.TypeAliasDeclaration || value === AstKind.VariableStatement;
	AstKind.__ks_eq_DescriptiveType = value => value === AstKind.BitmaskDeclaration || value === AstKind.ClassDeclaration || value === AstKind.EnumDeclaration || value === AstKind.FunctionDeclaration || value === AstKind.MacroDeclaration || value === AstKind.NamespaceDeclaration || value === AstKind.StructDeclaration || value === AstKind.SyntimeDeclaration || value === AstKind.TupleDeclaration || value === AstKind.TypeAliasDeclaration || value === AstKind.VariableStatement || value === AstKind.ExportDeclaration || value === AstKind.VariableDeclarator;
	const OperatorAttribute = Helper.bitmask(Number, ["Nil", 0, "Assignable", 1, "Binary", 2, "Comparable", 4, "Polyadic", 8, "RTL", 16, "Unary", 32]);
	const OperatorKind = Helper.enum(Number, 2, "attribute", "precedence", "Addition", 1, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 13, "Assignment", 2, OperatorAttribute.Binary, 3, "BackwardPipeline", 3, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.RTL), 20, "BitwiseAnd", 4, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "BitwiseNegation", 5, OperatorAttribute.Unary, 0, "BitwiseOr", 6, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "BitwiseXor", 7, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "BitwiseLeftShift", 8, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "BitwiseRightShift", 9, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 12, "Constant", 10, OperatorAttribute.Unary, 0, "Division", 11, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Empty", 12, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "EmptyCoalescing", 13, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 15, "Equality", 14, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "Equals", 15, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "EuclideanDivision", 16, OperatorAttribute.Binary, 14, "Existential", 17, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable | OperatorAttribute.Unary), 0, "Finite", 18, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable | OperatorAttribute.Unary), 0, "ForwardPipeline", 19, OperatorAttribute.Binary, 16, "GreaterThan", 20, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "GreaterThanOrEqual", 21, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "Implicit", 22, OperatorAttribute.Unary, 0, "Inequality", 23, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "IntegerDivision", 24, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "JunctionAnd", 25, OperatorAttribute.Binary, 0, "JunctionOr", 26, OperatorAttribute.Binary, 0, "JunctionXor", 27, OperatorAttribute.Binary, 0, "Length", 28, OperatorAttribute.Unary, 0, "LessThan", 29, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "LessThanOrEqual", 30, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Comparable), 8, "LogicalAnd", 31, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 6, "LogicalImply", 32, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 5, "LogicalNegation", 33, OperatorAttribute.Unary, 0, "LogicalOr", 34, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 5, "LogicalXor", 35, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 5, "Match", 36, OperatorAttribute.Binary, 8, "Mismatch", 37, OperatorAttribute.Binary, 8, "Modulus", 38, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Multiplication", 39, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Negative", 40, OperatorAttribute.Unary, 0, "NonEmpty", 41, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable | OperatorAttribute.Unary), 0, "NonExistential", 42, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "NonFinite", 43, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "NonFiniteCoalescing", 44, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 15, "NullCoalescing", 45, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 15, "Power", 46, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Remainder", 47, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 14, "Return", 48, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "Spread", 49, OperatorAttribute.Unary, 0, "Subtraction", 50, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 13, "TypeAssertion", 51, OperatorAttribute.Binary, 0, "TypeCasting", 52, OperatorAttribute.Binary, 0, "TypeEquality", 53, OperatorAttribute.Binary, 8, "TypeFitting", 54, OperatorAttribute.Unary, 0, "TypeInequality", 55, OperatorAttribute.Binary, 8, "TypeNotNull", 56, OperatorAttribute.Unary, 0, "TypeSignalment", 57, OperatorAttribute.Binary, 0, "VariantNo", 58, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable), 0, "VariantNoCoalescing", 59, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Polyadic | OperatorAttribute.Assignable), 15, "VariantYes", 60, OperatorAttribute(OperatorAttribute.Binary | OperatorAttribute.Assignable | OperatorAttribute.Unary), 0);
	const IterationKind = Helper.enum(Number, 0, "Array", 0, "From", 1, "Object", 2, "Range", 3, "Repeat", 4);
	const RestrictiveOperatorKind = Helper.enum(Number, 0, "If", 0, "Unless", 1);
	const UnaryTypeOperatorKind = Helper.enum(Number, 0, "Constant", 1, "Mutable", 2, "NewInstance", 3, "TypeOf", 4, "ValueOf", 5);
	const QuoteElementKind = Helper.enum(Number, 0, "Escape", 1, "Expression", 2, "Literal", 3, "NewLine", 4);
	const ReificationKind = Helper.enum(Number, 0, "Argument", 1, "Block", 2, "Code", 3, "Identifier", 4, "Join", 5, "Value", 6);
	const ScopeKind = Helper.enum(Number, 0, "Argument", 1, "This", 2);
	return {
		ModifierKind,
		AstKind,
		OperatorAttribute,
		OperatorKind,
		IterationKind,
		RestrictiveOperatorKind,
		UnaryTypeOperatorKind,
		QuoteElementKind,
		ReificationKind,
		ScopeKind,
		__ksType: [__ksType.isPosition, __ksType.isRange, __ksType.isVersionData, __ksType.isModifierData, __ksType.isAst, __ksType.isAssignmentOperatorKind, __ksType.isBinaryOperatorKind, __ksType.isUnaryOperatorKind, __ksType.isBinaryOperatorData, __ksType.isIterationData, __ksType.isRestrictiveOperatorData, __ksType.isUnaryOperatorData, __ksType.isUnaryTypeOperatorData, __ksType.isQuoteElementData, __ksType.isReificationData, __ksType.isScopeData]
	};
};
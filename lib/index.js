// Generated by kaoscript 0.11.0
const {Helper, Type} = require("@kaoscript/runtime");
module.exports = function() {
	const __ksType = {
		isPosition: value => Type.isDexObject(value, 1, 0, {line: Type.isNumber, column: Type.isNumber}),
		isRange: value => Type.isDexObject(value, 1, 0, {start: __ksType.isPosition, end: __ksType.isPosition}),
		isVersionData: value => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {major: Type.isString, minor: Type.isString, patch: Type.isString}),
		isMacroElementData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = MacroElementKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, MacroElementKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === MacroElementKind.Expression) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), reification: value => __ksType.isReificationData(value, cast) || Type.isNull(value), separator: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === MacroElementKind.Literal) {
				return Type.isDexObject(value, 0, 0, {value: Type.isString});
			}
			return true;
		}}),
		isReificationData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", ReificationKind, cast)}),
		isModifierData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = ModifierKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, ModifierKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === ModifierKind.Rest) {
				return Type.isDexObject(value, 0, 0, {arity: value => Type.isDexObject(value, 1, 0, {min: Type.isNumber, max: Type.isNumber}) || Type.isNull(value)});
			}
			return true;
		}}),
		isNodeData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = NodeKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, NodeKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === NodeKind.AccessorDeclaration) {
				return Type.isDexObject(value, 0, 0, {body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value)) || Type.isNull(value)});
			}
			if(variant === NodeKind.Argument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ArrayBinding) {
				return Type.isDexObject(value, 0, 0, {elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.BindingElement))});
			}
			if(variant === NodeKind.ArrayComprehension) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), loop: value => __ksType.isNodeData(value, cast, value => value === NodeKind.ForStatement || value === NodeKind.RepeatStatement)});
			}
			if(variant === NodeKind.ArrayExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), values: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.ArrayRange) {
				return Type.isDexObject(value, 0, 0, {from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), then: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), til: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), by: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.ArrayType) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.PropertyType)), rest: value => __ksType.isNodeData(value, cast, value => value === NodeKind.PropertyType) || Type.isNull(value)});
			}
			if(variant === NodeKind.AttributeDeclaration) {
				return Type.isDexObject(value, 0, 0, {declaration: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.AttributeExpression || value === NodeKind.AttributeOperation)});
			}
			if(variant === NodeKind.AttributeExpression) {
				return Type.isDexObject(value, 0, 0, {name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.AttributeOperation || value === NodeKind.AttributeExpression))});
			}
			if(variant === NodeKind.AttributeOperation) {
				return Type.isDexObject(value, 0, 0, {name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), value: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Literal)});
			}
			if(variant === NodeKind.AwaitExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), variables: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclarator)) || Type.isNull(value), operation: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.BinaryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), operator: __ksType.isBinaryOperatorData, left: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), right: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.ArrayType || value === NodeKind.ObjectType || value === NodeKind.TypeReference) || Type.isNull(value)});
			}
			if(variant === NodeKind.BindingElement) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), external: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), internal: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding || value === NodeKind.ThisExpression) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), operator: value => __ksType.isBinaryOperatorData(value, cast, value => value === BinaryOperatorKind.Assignment) || Type.isNull(value), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.BitmaskDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), type: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.BitmaskValue || value === NodeKind.MethodDeclaration))});
			}
			if(variant === NodeKind.BitmaskValue) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.Block) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), statements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Statement))});
			}
			if(variant === NodeKind.BlockStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), label: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block)});
			}
			if(variant === NodeKind.BreakStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), label: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.CallExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), scope: value => __ksType.isScopeData(value, cast), callee: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Argument(value) || NodeKind.__ks_eq_Expression(value)))});
			}
			if(variant === NodeKind.CatchClause) {
				return Type.isDexObject(value, 0, 0, {body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block), binding: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.ClassDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), version: value => __ksType.isVersionData(value) || Type.isNull(value), extends: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression) || Type.isNull(value), implements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression)) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_ClassMember))});
			}
			if(variant === NodeKind.ComparisonExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), values: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || (__ksType.isBinaryOperatorData(value)))});
			}
			if(variant === NodeKind.ComputedPropertyName) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ConditionalExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), whenTrue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), whenFalse: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ContinueStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), label: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.CurryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), scope: value => __ksType.isScopeData(value, cast), callee: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Argument(value) || NodeKind.__ks_eq_Expression(value)))});
			}
			if(variant === NodeKind.DeclarationSpecifier) {
				return Type.isDexObject(value, 0, 0, {declaration: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_SpecialDeclaration)});
			}
			if(variant === NodeKind.DiscloseDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_ClassMember))});
			}
			if(variant === NodeKind.DisruptiveExpression) {
				return Type.isDexObject(value, 0, 0, {operator: __ksType.isRestrictiveOperatorData, condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), mainExpression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), disruptedExpression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.DoUntilStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block)});
			}
			if(variant === NodeKind.DoWhileStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block)});
			}
			if(variant === NodeKind.EnumDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), type: value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeReference) || Type.isNull(value), initial: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), step: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.EnumValue || value === NodeKind.FieldDeclaration || value === NodeKind.MethodDeclaration))});
			}
			if(variant === NodeKind.EnumValue) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Argument(value) || NodeKind.__ks_eq_Expression(value))) || Type.isNull(value)});
			}
			if(variant === NodeKind.ExclusionType) {
				return Type.isDexObject(value, 0, 0, {types: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type))});
			}
			if(variant === NodeKind.ExportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.DeclarationSpecifier || value === NodeKind.GroupSpecifier || value === NodeKind.NamedSpecifier || value === NodeKind.PropertiesSpecifier))});
			}
			if(variant === NodeKind.ExpressionStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ExternDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.ExternOrImportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ImportDeclarator))});
			}
			if(variant === NodeKind.ExternOrRequireDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.FallthroughStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration))});
			}
			if(variant === NodeKind.FieldDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.ForStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), iteration: value => __ksType.isIterationData(value, cast) || Type.isNull(value), iterations: value => Type.isArray(value, __ksType.isIterationData) || Type.isNull(value), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.ExpressionStatement) || Type.isNull(value), else: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block) || Type.isNull(value)});
			}
			if(variant === NodeKind.FunctionDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeParameter)) || Type.isNull(value), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value) || value === NodeKind.IfStatement || value === NodeKind.UnlessStatement) || Type.isNull(value)});
			}
			if(variant === NodeKind.FunctionExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value) || value === NodeKind.IfStatement || value === NodeKind.UnlessStatement) || Type.isNull(value)});
			}
			if(variant === NodeKind.FusionType) {
				return Type.isDexObject(value, 0, 0, {types: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type))});
			}
			if(variant === NodeKind.GroupSpecifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.NamedSpecifier || value === NodeKind.TypedSpecifier)), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType) || Type.isNull(value)});
			}
			if(variant === NodeKind.Identifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), name: Type.isString});
			}
			if(variant === NodeKind.IfExpression) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), declaration: value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclaration) || Type.isNull(value), whenTrue: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block), whenFalse: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.IfExpression)});
			}
			if(variant === NodeKind.IfStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), declarations: value => Type.isArray(value, value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclaration || NodeKind.__ks_eq_Expression(value)))) || Type.isNull(value), whenTrue: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.BreakStatement || value === NodeKind.ContinueStatement || value === NodeKind.ExpressionStatement || value === NodeKind.ReturnStatement || value === NodeKind.SetStatement || value === NodeKind.ThrowStatement), whenFalse: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.IfStatement) || Type.isNull(value)});
			}
			if(variant === NodeKind.ImplementDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), variable: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression), interface: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression) || Type.isNull(value), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_ClassMember))});
			}
			if(variant === NodeKind.ImportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ImportDeclarator))});
			}
			if(variant === NodeKind.ImportDeclarator) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), source: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Literal), arguments: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.NamedArgument || value === NodeKind.PositionalArgument)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_DescriptiveType(value) || value === NodeKind.TypeList) || Type.isNull(value), specifiers: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.GroupSpecifier || value === NodeKind.NamedSpecifier))});
			}
			if(variant === NodeKind.IncludeAgainDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.IncludeDeclarator))});
			}
			if(variant === NodeKind.IncludeDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.IncludeDeclarator))});
			}
			if(variant === NodeKind.IncludeDeclarator) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), file: Type.isString});
			}
			if(variant === NodeKind.JunctionExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), operator: __ksType.isBinaryOperatorData, operands: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || NodeKind.__ks_eq_Type(value)))});
			}
			if(variant === NodeKind.LambdaExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value))});
			}
			if(variant === NodeKind.Literal) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), value: Type.isString});
			}
			if(variant === NodeKind.MacroDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.ExpressionStatement)});
			}
			if(variant === NodeKind.MacroExpression) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), elements: value => Type.isArray(value, __ksType.isMacroElementData)});
			}
			if(variant === NodeKind.MatchClause) {
				return Type.isDexObject(value, 0, 0, {conditions: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.MatchConditionArray || value === NodeKind.MatchConditionObject || value === NodeKind.MatchConditionRange || value === NodeKind.MatchConditionType)), binding: value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclarator || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding) || Type.isNull(value), filter: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Statement(value))});
			}
			if(variant === NodeKind.MatchConditionArray) {
				return Type.isDexObject(value, 0, 0, {values: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.MatchConditionRange || value === NodeKind.OmittedExpression))});
			}
			if(variant === NodeKind.MatchConditionObject) {
				return Type.isDexObject(value, 0, 0, {properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ObjectMember))});
			}
			if(variant === NodeKind.MatchConditionRange) {
				return Type.isDexObject(value, 0, 0, {from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), then: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), til: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.MatchConditionType) {
				return Type.isDexObject(value, 0, 0, {type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type)});
			}
			if(variant === NodeKind.MatchExpression) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), clauses: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.MatchClause))});
			}
			if(variant === NodeKind.MatchStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), declaration: value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclaration) || Type.isNull(value), clauses: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.MatchClause))});
			}
			if(variant === NodeKind.MemberExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), object: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), property: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.MethodDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeParameter)) || Type.isNull(value), parameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Parameter)), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), throws: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value) || value === NodeKind.IfStatement || value === NodeKind.UnlessStatement) || Type.isNull(value)});
			}
			if(variant === NodeKind.Module) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), body: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Statement(value) || value === NodeKind.ShebangDeclaration))});
			}
			if(variant === NodeKind.MutatorDeclaration) {
				return Type.isDexObject(value, 0, 0, {body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value)) || Type.isNull(value)});
			}
			if(variant === NodeKind.NamedArgument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), value: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.PlaceholderArgument)});
			}
			if(variant === NodeKind.NamedSpecifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), internal: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding), external: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === NodeKind.NamespaceDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), statements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Statement(value) || NodeKind.__ks_eq_DescriptiveType(value) || value === NodeKind.ExportDeclaration || value === NodeKind.ExternDeclaration))});
			}
			if(variant === NodeKind.NumericExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), value: Type.isNumber, radix: Type.isNumber});
			}
			if(variant === NodeKind.ObjectBinding) {
				return Type.isDexObject(value, 0, 0, {elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.BindingElement))});
			}
			if(variant === NodeKind.ObjectExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.ObjectMember) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ComputedPropertyName || value === NodeKind.Literal || value === NodeKind.TemplateExpression) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), value: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.MatchConditionRange) || Type.isNull(value)});
			}
			if(variant === NodeKind.ObjectType) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.PropertyType)), rest: value => __ksType.isNodeData(value, cast, value => value === NodeKind.PropertyType) || Type.isNull(value)});
			}
			if(variant === NodeKind.OmittedExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData)});
			}
			if(variant === NodeKind.PassStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration))});
			}
			if(variant === NodeKind.Parameter) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), external: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), internal: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding || value === NodeKind.ThisExpression) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), operator: value => __ksType.isBinaryOperatorData(value, cast, value => value === BinaryOperatorKind.Assignment) || Type.isNull(value), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.PlaceholderArgument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), index: value => __ksType.isNodeData(value, cast, value => value === NodeKind.NumericExpression) || Type.isNull(value)});
			}
			if(variant === NodeKind.PolyadicExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), operator: __ksType.isBinaryOperatorData, operands: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.PositionalArgument) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.PropertiesSpecifier) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), object: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.NamedSpecifier))});
			}
			if(variant === NodeKind.PropertyDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), accessor: value => __ksType.isNodeData(value, cast, value => value === NodeKind.AccessorDeclaration) || Type.isNull(value), mutator: value => __ksType.isNodeData(value, cast, value => value === NodeKind.MutatorDeclaration) || Type.isNull(value)});
			}
			if(variant === NodeKind.PropertyType) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === NodeKind.ProxyDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), internal: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), external: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ProxyGroupDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), recipient: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ProxyDeclaration))});
			}
			if(variant === NodeKind.Reference) {
				return Type.isDexObject(value, 0, 0, {name: Type.isString});
			}
			if(variant === NodeKind.RegularExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), value: Type.isString});
			}
			if(variant === NodeKind.RepeatStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.ExpressionStatement) || Type.isNull(value)});
			}
			if(variant === NodeKind.RequireDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.RequireOrExternDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.RequireOrImportDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.ImportDeclarator))});
			}
			if(variant === NodeKind.RestrictiveExpression) {
				return Type.isDexObject(value, 0, 0, {operator: __ksType.isRestrictiveOperatorData, condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.ReturnStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.RollingExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), object: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), expressions: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.SequenceExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), expressions: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.SetStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.ShebangDeclaration) {
				return Type.isDexObject(value, 0, 0, {command: Type.isString});
			}
			if(variant === NodeKind.ShorthandProperty) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ComputedPropertyName || value === NodeKind.Literal || value === NodeKind.TemplateExpression || value === NodeKind.ThisExpression)});
			}
			if(variant === NodeKind.SpreadExpression) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), operand: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), members: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.NamedSpecifier))});
			}
			if(variant === NodeKind.StatementList) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), body: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Statement))});
			}
			if(variant === NodeKind.StructDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), extends: value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeReference) || Type.isNull(value), implements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression)) || Type.isNull(value), fields: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.FieldDeclaration))});
			}
			if(variant === NodeKind.TaggedTemplateExpression) {
				return Type.isDexObject(value, 0, 0, {tag: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), template: value => __ksType.isNodeData(value, cast, value => value === NodeKind.TemplateExpression)});
			}
			if(variant === NodeKind.TemplateExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), elements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression))});
			}
			if(variant === NodeKind.ThisExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)});
			}
			if(variant === NodeKind.ThrowStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.TopicReference) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData)});
			}
			if(variant === NodeKind.TryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), argument: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.TryStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block), catchClauses: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.CatchClause)), catchClause: value => __ksType.isNodeData(value, cast, value => value === NodeKind.CatchClause) || Type.isNull(value), finalizer: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block) || Type.isNull(value)});
			}
			if(variant === NodeKind.TupleDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), extends: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), implements: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression)) || Type.isNull(value), fields: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TupleField))});
			}
			if(variant === NodeKind.TupleField) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), defaultValue: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.TypedSpecifier) {
				return Type.isDexObject(value, 0, 0, {type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType)});
			}
			if(variant === NodeKind.TypeAliasDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeParameter)) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type)});
			}
			if(variant === NodeKind.TypeList) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), types: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_DescriptiveType))});
			}
			if(variant === NodeKind.TypeParameter) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), constraint: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === NodeKind.TypeReference) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), typeName: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.MemberExpression || value === NodeKind.UnaryExpression) || Type.isNull(value), typeParameters: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type)) || Type.isNull(value), typeSubtypes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)) || __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.UnaryExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), operator: __ksType.isUnaryOperatorData, argument: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression)});
			}
			if(variant === NodeKind.UnaryTypeExpression) {
				return Type.isDexObject(value, 0, 0, {modifiers: value => Type.isArray(value, __ksType.isModifierData), operator: __ksType.isUnaryTypeOperatorData, argument: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Type(value) || NodeKind.__ks_eq_Expression(value))});
			}
			if(variant === NodeKind.UnionType) {
				return Type.isDexObject(value, 0, 0, {types: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type))});
			}
			if(variant === NodeKind.UnlessStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), whenFalse: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || value === NodeKind.BreakStatement || value === NodeKind.ContinueStatement || value === NodeKind.ExpressionStatement || value === NodeKind.ReturnStatement || value === NodeKind.SetStatement || value === NodeKind.ThrowStatement)});
			}
			if(variant === NodeKind.UntilStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value))});
			}
			if(variant === NodeKind.VariableDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), variables: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclarator)), operator: value => __ksType.isBinaryOperatorData(value, cast, value => value === BinaryOperatorKind.Assignment) || Type.isNull(value), value: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === NodeKind.VariableDeclarator) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === NodeKind.VariableStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), declarations: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariableDeclaration))});
			}
			if(variant === NodeKind.VariantDeclaration) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), name: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), fields: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariantField))});
			}
			if(variant === NodeKind.VariantField) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), modifiers: value => Type.isArray(value, __ksType.isModifierData), names: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier)), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value)});
			}
			if(variant === NodeKind.VariantType) {
				return Type.isDexObject(value, 0, 0, {master: value => __ksType.isNodeData(value, cast, value => value === NodeKind.TypeReference), properties: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.VariantField))});
			}
			if(variant === NodeKind.WhileStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), condition: value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.VariableDeclaration), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block || NodeKind.__ks_eq_Expression(value))});
			}
			if(variant === NodeKind.WithStatement) {
				return Type.isDexObject(value, 0, 0, {attributes: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => value === NodeKind.AttributeDeclaration)), variables: value => Type.isArray(value, value => __ksType.isNodeData(value, cast, value => NodeKind.__ks_eq_Expression(value) || value === NodeKind.VariableDeclaration)), body: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block), finalizer: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Block) || Type.isNull(value)});
			}
			return true;
		}}),
		isBinaryOperatorData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = BinaryOperatorKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, BinaryOperatorKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === BinaryOperatorKind.Assignment) {
				return Type.isDexObject(value, 0, 0, {assignment: () => Helper.castEnum(value, "assignment", AssignmentOperatorKind, cast)});
			}
			return true;
		}, modifiers: value => Type.isArray(value, __ksType.isModifierData) || Type.isNull(value)}),
		isIterationData: (value, cast, filter) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: variant => {
			if(cast) {
				if((variant = IterationKind(variant)) === null) {
					return false;
				}
				value["kind"] = variant;
			}
			else if(!Type.isEnumInstance(variant, IterationKind)) {
				return false;
			}
			if(filter && !filter(variant)) {
				return false;
			}
			if(variant === IterationKind.Array) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), value: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), index: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), step: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), split: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === IterationKind.From) {
				return Type.isDexObject(value, 0, 0, {variable: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), step: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			if(variant === IterationKind.Object) {
				return Type.isDexObject(value, 0, 0, {expression: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), value: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ArrayBinding || value === NodeKind.ObjectBinding) || Type.isNull(value), type: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Type) || Type.isNull(value), key: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value)});
			}
			if(variant === IterationKind.Range) {
				return Type.isDexObject(value, 0, 0, {value: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier), index: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier) || Type.isNull(value), from: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), to: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression), step: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)});
			}
			return true;
		}, modifiers: value => Type.isArray(value, __ksType.isModifierData), until: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), while: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value), when: value => __ksType.isNodeData(value, cast, NodeKind.__ks_eq_Expression) || Type.isNull(value)}),
		isRestrictiveOperatorData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", RestrictiveOperatorKind, cast), modifiers: value => Type.isArray(value, __ksType.isModifierData) || Type.isNull(value)}),
		isUnaryOperatorData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", UnaryOperatorKind, cast)}),
		isUnaryTypeOperatorData: (value, cast) => __ksType.isRange(value) && Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", UnaryTypeOperatorKind, cast)}),
		isScopeData: (value, cast) => Type.isDexObject(value, 1, 0, {kind: () => Helper.castEnum(value, "kind", ScopeKind, cast), value: value => __ksType.isNodeData(value, cast, value => value === NodeKind.Identifier || value === NodeKind.ObjectExpression) || Type.isNull(value)})
	};
	const MacroElementKind = Helper.enum(Number, 0, "Expression", 1, "Literal", 2, "NewLine", 3);
	const ReificationKind = Helper.enum(Number, 0, "Argument", 1, "Expression", 2, "Join", 3, "Statement", 4, "Write", 5);
	const ModifierKind = Helper.enum(Number, 0, "Abstract", 1, "Alias", 2, "Ascending", 3, "Async", 4, "Assist", 5, "AutoEvaluate", 6, "Autofill", 7, "AutoType", 8, "Ballpark", 9, "Computed", 10, "Constant", 11, "Declarative", 12, "Default", 13, "Descending", 14, "Disabled", 15, "Dynamic", 16, "Exclusion", 17, "Existential", 18, "Final", 19, "Forced", 20, "Internal", 21, "LateInit", 22, "LazyInit", 23, "MultiLine", 24, "Mutable", 25, "Named", 26, "NameOnly", 27, "NonEmpty", 28, "NonNullable", 29, "Nullable", 30, "Ordinal", 31, "Override", 32, "Overwrite", 33, "PositionOnly", 34, "Private", 35, "Protected", 36, "Public", 37, "Required", 38, "Rest", 39, "Sealed", 40, "Spread", 41, "Static", 42, "System", 43, "ThisAlias", 44, "Wildcard", 45);
	const NodeKind = Helper.enum(Number, 0, "AccessorDeclaration", 1, "ArrayBinding", 2, "ArrayComprehension", 3, "ArrayExpression", 4, "ArrayRange", 5, "ArrayType", 6, "AttributeDeclaration", 7, "AttributeExpression", 8, "AttributeOperation", 9, "AwaitExpression", 10, "BinaryExpression", 11, "BindingElement", 12, "BitmaskDeclaration", 13, "BitmaskValue", 14, "Block", 15, "BlockStatement", 16, "BreakStatement", 17, "CallExpression", 18, "CatchClause", 19, "ClassDeclaration", 20, "ClassName", 21, "CommentBlock", 22, "CommentLine", 23, "ComparisonExpression", 24, "ComputedPropertyName", 25, "ConditionalExpression", 26, "ContinueStatement", 27, "CurryExpression", 28, "DeclarationSpecifier", 29, "DiscloseDeclaration", 30, "DisruptiveExpression", 31, "DoUntilStatement", 32, "DoWhileStatement", 33, "EnumDeclaration", 34, "EnumValue", 35, "ExclusionType", 36, "ExportDeclaration", 37, "ExternDeclaration", 38, "ExternOrImportDeclaration", 39, "ExternOrRequireDeclaration", 40, "ExpressionStatement", 41, "FallthroughStatement", 42, "FieldDeclaration", 43, "ForStatement", 44, "FunctionDeclaration", 45, "FunctionExpression", 46, "FusionType", 47, "GroupSpecifier", 48, "Identifier", 49, "IfExpression", 50, "IfStatement", 51, "ImplementDeclaration", 52, "ImportDeclaration", 53, "ImportDeclarator", 54, "IncludeAgainDeclaration", 55, "IncludeDeclaration", 56, "IncludeDeclarator", 57, "JunctionExpression", 58, "LambdaExpression", 59, "Literal", 60, "MacroDeclaration", 61, "MacroExpression", 62, "MatchClause", 63, "MatchConditionArray", 64, "MatchConditionObject", 65, "MatchConditionRange", 66, "MatchConditionType", 67, "MatchExpression", 68, "MatchStatement", 69, "MemberExpression", 70, "MethodDeclaration", 71, "MixinDeclaration", 72, "Module", 73, "MutatorDeclaration", 74, "NamedArgument", 75, "NamedSpecifier", 76, "NamespaceDeclaration", 77, "NumericExpression", 78, "ObjectBinding", 79, "ObjectExpression", 80, "ObjectMember", 81, "ObjectType", 82, "OmittedExpression", 83, "Parameter", 84, "PassStatement", 85, "PlaceholderArgument", 86, "PolyadicExpression", 87, "PositionalArgument", 88, "PropertiesSpecifier", 89, "PropertyDeclaration", 90, "PropertyType", 91, "ProxyDeclaration", 92, "ProxyGroupDeclaration", 93, "Reference", 94, "RegularExpression", 95, "RepeatStatement", 96, "RequireDeclaration", 97, "RequireOrExternDeclaration", 98, "RequireOrImportDeclaration", 99, "RestrictiveExpression", 100, "ReturnStatement", 101, "RollingExpression", 102, "SequenceExpression", 103, "SetStatement", 104, "ShebangDeclaration", 105, "ShorthandProperty", 106, "SpreadExpression", 107, "StatementList", 108, "StructDeclaration", 109, "SurrogateDeclaration", 110, "TaggedTemplateExpression", 111, "TemplateExpression", 112, "ThisExpression", 113, "ThrowStatement", 114, "TopicReference", 115, "TraitDeclaration", 116, "TryExpression", 117, "TryStatement", 118, "TupleDeclaration", 119, "TupleField", 120, "TypeAliasDeclaration", 121, "TypeList", 122, "TypeParameter", 123, "TypeReference", 124, "TypedSpecifier", 125, "UnaryExpression", 126, "UnaryTypeExpression", 127, "UnlessStatement", 128, "UntilStatement", 129, "UnionType", 130, "VariableDeclaration", 131, "VariableDeclarator", 132, "VariableStatement", 133, "VariantDeclaration", 134, "VariantField", 135, "VariantType", 136, "WhileStatement", 137, "WithStatement", 138);
	NodeKind.__ks_eq_Argument = value => value === NodeKind.NamedArgument || value === NodeKind.PlaceholderArgument || value === NodeKind.PositionalArgument;
	NodeKind.__ks_eq_ClassMember = value => value === NodeKind.FieldDeclaration || value === NodeKind.MacroDeclaration || value === NodeKind.MethodDeclaration || value === NodeKind.PropertyDeclaration || value === NodeKind.ProxyDeclaration || value === NodeKind.ProxyGroupDeclaration;
	NodeKind.__ks_eq_Expression = value => value === NodeKind.ArrayBinding || value === NodeKind.ArrayComprehension || value === NodeKind.ArrayExpression || value === NodeKind.ArrayRange || value === NodeKind.AwaitExpression || value === NodeKind.BinaryExpression || value === NodeKind.CallExpression || value === NodeKind.ComparisonExpression || value === NodeKind.ConditionalExpression || value === NodeKind.CurryExpression || value === NodeKind.DisruptiveExpression || value === NodeKind.FunctionExpression || value === NodeKind.Identifier || value === NodeKind.IfExpression || value === NodeKind.JunctionExpression || value === NodeKind.LambdaExpression || value === NodeKind.Literal || value === NodeKind.MacroExpression || value === NodeKind.MatchExpression || value === NodeKind.MemberExpression || value === NodeKind.NamedArgument || value === NodeKind.NumericExpression || value === NodeKind.ObjectBinding || value === NodeKind.ObjectExpression || value === NodeKind.ObjectMember || value === NodeKind.PlaceholderArgument || value === NodeKind.PolyadicExpression || value === NodeKind.PositionalArgument || value === NodeKind.Reference || value === NodeKind.RegularExpression || value === NodeKind.RestrictiveExpression || value === NodeKind.RollingExpression || value === NodeKind.SequenceExpression || value === NodeKind.ShorthandProperty || value === NodeKind.SpreadExpression || value === NodeKind.TaggedTemplateExpression || value === NodeKind.TemplateExpression || value === NodeKind.ThisExpression || value === NodeKind.TopicReference || value === NodeKind.TryExpression || value === NodeKind.UnaryExpression;
	NodeKind.__ks_eq_Statement = value => value === NodeKind.BitmaskDeclaration || value === NodeKind.BlockStatement || value === NodeKind.BreakStatement || value === NodeKind.ClassDeclaration || value === NodeKind.ContinueStatement || value === NodeKind.DiscloseDeclaration || value === NodeKind.DoUntilStatement || value === NodeKind.DoWhileStatement || value === NodeKind.EnumDeclaration || value === NodeKind.ExportDeclaration || value === NodeKind.ExternDeclaration || value === NodeKind.ExternOrImportDeclaration || value === NodeKind.ExternOrRequireDeclaration || value === NodeKind.ExpressionStatement || value === NodeKind.FallthroughStatement || value === NodeKind.ForStatement || value === NodeKind.FunctionDeclaration || value === NodeKind.IfStatement || value === NodeKind.ImplementDeclaration || value === NodeKind.ImportDeclaration || value === NodeKind.IncludeAgainDeclaration || value === NodeKind.IncludeDeclaration || value === NodeKind.MacroDeclaration || value === NodeKind.MatchStatement || value === NodeKind.NamespaceDeclaration || value === NodeKind.PassStatement || value === NodeKind.RepeatStatement || value === NodeKind.RequireDeclaration || value === NodeKind.RequireOrExternDeclaration || value === NodeKind.RequireOrImportDeclaration || value === NodeKind.ReturnStatement || value === NodeKind.SetStatement || value === NodeKind.StructDeclaration || value === NodeKind.ThrowStatement || value === NodeKind.TraitDeclaration || value === NodeKind.TryStatement || value === NodeKind.TupleDeclaration || value === NodeKind.TypeAliasDeclaration || value === NodeKind.UnlessStatement || value === NodeKind.UntilStatement || value === NodeKind.VariableStatement || value === NodeKind.VariantDeclaration || value === NodeKind.WhileStatement || value === NodeKind.WithStatement;
	NodeKind.__ks_eq_Type = value => value === NodeKind.ArrayType || value === NodeKind.ExclusionType || value === NodeKind.FunctionExpression || value === NodeKind.FusionType || value === NodeKind.ObjectType || value === NodeKind.TypeReference || value === NodeKind.UnaryTypeExpression || value === NodeKind.UnionType || value === NodeKind.VariantType;
	NodeKind.__ks_eq_SpecialDeclaration = value => value === NodeKind.BitmaskDeclaration || value === NodeKind.ClassDeclaration || value === NodeKind.EnumDeclaration || value === NodeKind.FunctionDeclaration || value === NodeKind.MacroDeclaration || value === NodeKind.MacroExpression || value === NodeKind.NamespaceDeclaration || value === NodeKind.StructDeclaration || value === NodeKind.TupleDeclaration || value === NodeKind.TypeAliasDeclaration || value === NodeKind.VariableStatement;
	NodeKind.__ks_eq_DescriptiveType = value => value === NodeKind.BitmaskDeclaration || value === NodeKind.ClassDeclaration || value === NodeKind.EnumDeclaration || value === NodeKind.FunctionDeclaration || value === NodeKind.MacroDeclaration || value === NodeKind.MacroExpression || value === NodeKind.NamespaceDeclaration || value === NodeKind.StructDeclaration || value === NodeKind.TupleDeclaration || value === NodeKind.TypeAliasDeclaration || value === NodeKind.VariableStatement || value === NodeKind.ExportDeclaration || value === NodeKind.VariableDeclarator;
	const AssignmentOperatorKind = Helper.enum(Number, 0, "Addition", 1, "BitwiseAnd", 2, "BitwiseOr", 3, "BitwiseXor", 4, "BitwiseLeftShift", 5, "BitwiseRightShift", 6, "Division", 7, "Empty", 8, "EmptyCoalescing", 9, "Equals", 10, "Existential", 11, "LogicalAnd", 12, "LogicalOr", 13, "LogicalXor", 14, "Modulo", 15, "Multiplication", 16, "NonEmpty", 17, "NonExistential", 18, "NullCoalescing", 19, "Quotient", 20, "Return", 21, "Subtraction", 22);
	const BinaryOperatorKind = Helper.enum(Number, 0, "Addition", 1, "Assignment", 2, "BackwardPipeline", 3, "BitwiseAnd", 4, "BitwiseOr", 5, "BitwiseXor", 6, "BitwiseLeftShift", 7, "BitwiseRightShift", 8, "Division", 9, "EmptyCoalescing", 10, "Equality", 11, "ForwardPipeline", 12, "GreaterThan", 13, "GreaterThanOrEqual", 14, "Inequality", 15, "JunctionAnd", 16, "JunctionOr", 17, "JunctionXor", 18, "LessThan", 19, "LessThanOrEqual", 20, "LogicalAnd", 21, "LogicalImply", 22, "LogicalOr", 23, "LogicalXor", 24, "Match", 25, "Mismatch", 26, "Modulo", 27, "Multiplication", 28, "NullCoalescing", 29, "Quotient", 30, "Subtraction", 31, "TypeCasting", 32, "TypeEquality", 33, "TypeInequality", 34);
	const IterationKind = Helper.enum(Number, 0, "Array", 0, "From", 1, "Object", 2, "Range", 3);
	const RestrictiveOperatorKind = Helper.enum(Number, 0, "If", 0, "Unless", 1);
	const UnaryOperatorKind = Helper.enum(Number, 0, "BitwiseNegation", 1, "Constant", 2, "Existential", 3, "Implicit", 4, "LogicalNegation", 5, "Negative", 6, "NonEmpty", 7, "Spread", 8, "TypeFitting", 9);
	const UnaryTypeOperatorKind = Helper.enum(Number, 0, "Constant", 1, "Mutable", 2, "NewInstance", 3, "TypeOf", 4, "ValueOf", 5);
	const ScopeKind = Helper.enum(Number, 0, "Argument", 1, "This", 2);
	return {
		MacroElementKind,
		ReificationKind,
		ModifierKind,
		NodeKind,
		AssignmentOperatorKind,
		BinaryOperatorKind,
		IterationKind,
		RestrictiveOperatorKind,
		UnaryOperatorKind,
		UnaryTypeOperatorKind,
		ScopeKind,
		__ksType: [__ksType.isPosition, __ksType.isRange, __ksType.isVersionData, __ksType.isMacroElementData, __ksType.isReificationData, __ksType.isModifierData, __ksType.isNodeData, __ksType.isBinaryOperatorData, __ksType.isIterationData, __ksType.isRestrictiveOperatorData, __ksType.isUnaryOperatorData, __ksType.isUnaryTypeOperatorData, __ksType.isScopeData]
	};
};